<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>GCDAsyncSocket Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<meta name="viewport" content="width=550" />
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 840)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">CocoaAsyncSocket 0.0.1 </a></h1>
				<a id="developerHome" href="../index.html">Dustin Voss and Robbie Hanson</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">GCDAsyncSocket Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/CRData">&nbsp;&nbsp;&nbsp;&nbsp;+ CRData</option>
	
	<option value="//api/name/CRLFData">&nbsp;&nbsp;&nbsp;&nbsp;+ CRLFData</option>
	
	<option value="//api/name/LFData">&nbsp;&nbsp;&nbsp;&nbsp;+ LFData</option>
	
	<option value="//api/name/ZeroData">&nbsp;&nbsp;&nbsp;&nbsp;+ ZeroData</option>
	
	<option value="//api/name/getHost:port:fromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ getHost:port:fromAddress:</option>
	
	<option value="//api/name/hostFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ hostFromAddress:</option>
	
	<option value="//api/name/portFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ portFromAddress:</option>
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/acceptOnInterface:port:error:">&nbsp;&nbsp;&nbsp;&nbsp;- acceptOnInterface:port:error:</option>
	
	<option value="//api/name/acceptOnPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- acceptOnPort:error:</option>
	
	<option value="//api/name/autoDisconnectOnClosedReadStream">&nbsp;&nbsp;&nbsp;&nbsp;- autoDisconnectOnClosedReadStream</option>
	
	<option value="//api/name/connectToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:error:</option>
	
	<option value="//api/name/connectToAddress:viaInterface:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:viaInterface:withTimeout:error:</option>
	
	<option value="//api/name/connectToAddress:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:withTimeout:error:</option>
	
	<option value="//api/name/connectToHost:onPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:error:</option>
	
	<option value="//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:viaInterface:withTimeout:error:</option>
	
	<option value="//api/name/connectToHost:onPort:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:withTimeout:error:</option>
	
	<option value="//api/name/connectedAddress">&nbsp;&nbsp;&nbsp;&nbsp;- connectedAddress</option>
	
	<option value="//api/name/connectedHost">&nbsp;&nbsp;&nbsp;&nbsp;- connectedHost</option>
	
	<option value="//api/name/connectedPort">&nbsp;&nbsp;&nbsp;&nbsp;- connectedPort</option>
	
	<option value="//api/name/delegate">&nbsp;&nbsp;&nbsp;&nbsp;- delegate</option>
	
	<option value="//api/name/delegateQueue">&nbsp;&nbsp;&nbsp;&nbsp;- delegateQueue</option>
	
	<option value="//api/name/disconnect">&nbsp;&nbsp;&nbsp;&nbsp;- disconnect</option>
	
	<option value="//api/name/disconnectAfterReading">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterReading</option>
	
	<option value="//api/name/disconnectAfterReadingAndWriting">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterReadingAndWriting</option>
	
	<option value="//api/name/disconnectAfterWriting">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterWriting</option>
	
	<option value="//api/name/enableBackgroundingOnSocket">&nbsp;&nbsp;&nbsp;&nbsp;- enableBackgroundingOnSocket</option>
	
	<option value="//api/name/getDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- getDelegate:delegateQueue:</option>
	
	<option value="//api/name/init">&nbsp;&nbsp;&nbsp;&nbsp;- init</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:socketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:socketQueue:</option>
	
	<option value="//api/name/initWithSocketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithSocketQueue:</option>
	
	<option value="//api/name/isConnected">&nbsp;&nbsp;&nbsp;&nbsp;- isConnected</option>
	
	<option value="//api/name/isDisconnected">&nbsp;&nbsp;&nbsp;&nbsp;- isDisconnected</option>
	
	<option value="//api/name/isIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4</option>
	
	<option value="//api/name/isIPv4Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4Enabled</option>
	
	<option value="//api/name/isIPv4PreferredOverIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4PreferredOverIPv6</option>
	
	<option value="//api/name/isIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6</option>
	
	<option value="//api/name/isIPv6Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6Enabled</option>
	
	<option value="//api/name/isSecure">&nbsp;&nbsp;&nbsp;&nbsp;- isSecure</option>
	
	<option value="//api/name/localAddress">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress</option>
	
	<option value="//api/name/localHost">&nbsp;&nbsp;&nbsp;&nbsp;- localHost</option>
	
	<option value="//api/name/localPort">&nbsp;&nbsp;&nbsp;&nbsp;- localPort</option>
	
	<option value="//api/name/markSocketQueueTargetQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- markSocketQueueTargetQueue:</option>
	
	<option value="//api/name/performBlock:">&nbsp;&nbsp;&nbsp;&nbsp;- performBlock:</option>
	
	<option value="//api/name/progressOfReadReturningTag:bytesDone:total:">&nbsp;&nbsp;&nbsp;&nbsp;- progressOfReadReturningTag:bytesDone:total:</option>
	
	<option value="//api/name/progressOfWriteReturningTag:bytesDone:total:">&nbsp;&nbsp;&nbsp;&nbsp;- progressOfWriteReturningTag:bytesDone:total:</option>
	
	<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:maxLength:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:tag:</option>
	
	<option value="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToLength:withTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataToLength:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToLength:withTimeout:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:tag:</option>
	
	<option value="//api/name/readStream">&nbsp;&nbsp;&nbsp;&nbsp;- readStream</option>
	
	<option value="//api/name/setAutoDisconnectOnClosedReadStream:">&nbsp;&nbsp;&nbsp;&nbsp;- setAutoDisconnectOnClosedReadStream:</option>
	
	<option value="//api/name/setDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:</option>
	
	<option value="//api/name/setDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:delegateQueue:</option>
	
	<option value="//api/name/setDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegateQueue:</option>
	
	<option value="//api/name/setIPv4Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv4Enabled:</option>
	
	<option value="//api/name/setIPv6Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv6Enabled:</option>
	
	<option value="//api/name/setPreferIPv4OverIPv6:">&nbsp;&nbsp;&nbsp;&nbsp;- setPreferIPv4OverIPv6:</option>
	
	<option value="//api/name/setUserData:">&nbsp;&nbsp;&nbsp;&nbsp;- setUserData:</option>
	
	<option value="//api/name/socket4FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket4FD</option>
	
	<option value="//api/name/socket6FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket6FD</option>
	
	<option value="//api/name/socketFD">&nbsp;&nbsp;&nbsp;&nbsp;- socketFD</option>
	
	<option value="//api/name/sslContext">&nbsp;&nbsp;&nbsp;&nbsp;- sslContext</option>
	
	<option value="//api/name/startTLS:">&nbsp;&nbsp;&nbsp;&nbsp;- startTLS:</option>
	
	<option value="//api/name/synchronouslySetDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:</option>
	
	<option value="//api/name/synchronouslySetDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:delegateQueue:</option>
	
	<option value="//api/name/synchronouslySetDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegateQueue:</option>
	
	<option value="//api/name/unmarkSocketQueueTargetQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- unmarkSocketQueueTargetQueue:</option>
	
	<option value="//api/name/userData">&nbsp;&nbsp;&nbsp;&nbsp;- userData</option>
	
	<option value="//api/name/writeData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- writeData:withTimeout:tag:</option>
	
	<option value="//api/name/writeStream">&nbsp;&nbsp;&nbsp;&nbsp;- writeStream</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				



<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/CRData">CRData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/CRLFData">CRLFData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/LFData">LFData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/ZeroData">ZeroData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getHost:port:fromAddress:">getHost:port:fromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/hostFromAddress:">hostFromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/portFromAddress:">portFromAddress:</a></span></li>
	
</ul></li>



<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/acceptOnInterface:port:error:">acceptOnInterface:port:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/autoDisconnectOnClosedReadStream">autoDisconnectOnClosedReadStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:viaInterface:withTimeout:error:">connectToAddress:viaInterface:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:withTimeout:error:">connectToAddress:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">connectToHost:onPort:viaInterface:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:withTimeout:error:">connectToHost:onPort:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedAddress">connectedAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedHost">connectedHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedPort">connectedPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegate">delegate</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegateQueue">delegateQueue</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnect">disconnect</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterReading">disconnectAfterReading</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterReadingAndWriting">disconnectAfterReadingAndWriting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterWriting">disconnectAfterWriting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/enableBackgroundingOnSocket">enableBackgroundingOnSocket</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getDelegate:delegateQueue:">getDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/init">init</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:">initWithDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">initWithDelegate:delegateQueue:socketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithSocketQueue:">initWithSocketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isConnected">isConnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isDisconnected">isDisconnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4">isIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Enabled">isIPv4Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4PreferredOverIPv6">isIPv4PreferredOverIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6">isIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Enabled">isIPv6Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isSecure">isSecure</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress">localAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost">localHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort">localPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/markSocketQueueTargetQueue:">markSocketQueueTargetQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/performBlock:">performBlock:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">progressOfReadReturningTag:bytesDone:total:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/progressOfWriteReturningTag:bytesDone:total:">progressOfWriteReturningTag:bytesDone:total:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">readDataToData:withTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">readDataToData:withTimeout:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:tag:">readDataToData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToLength:withTimeout:tag:">readDataToLength:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">readDataWithTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:tag:">readDataWithTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readStream">readStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setAutoDisconnectOnClosedReadStream:">setAutoDisconnectOnClosedReadStream:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:">setDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:delegateQueue:">setDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegateQueue:">setDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv4Enabled:">setIPv4Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv6Enabled:">setIPv6Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setPreferIPv4OverIPv6:">setPreferIPv4OverIPv6:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setUserData:">setUserData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket4FD">socket4FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket6FD">socket6FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socketFD">socketFD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sslContext">sslContext</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/startTLS:">startTLS:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:">synchronouslySetDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">synchronouslySetDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegateQueue:">synchronouslySetDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/unmarkSocketQueueTargetQueue:">unmarkSocketQueueTargetQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/userData">userData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeData:withTimeout:tag:">writeData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeStream">writeStream</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="GCDAsyncSocket Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">GCDAsyncSocket Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">GCDAsyncSocket.h</td>
</tr>
						</tbody></table></div>
					
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
		<span class="tooltip"><p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithSocketQueue:">&ndash;&nbsp;initWithSocketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:socketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:">&ndash;&nbsp;setDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:">&ndash;&nbsp;synchronouslySetDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegateQueue">&ndash;&nbsp;delegateQueue</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegateQueue:">&ndash;&nbsp;setDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegateQueue:">&ndash;&nbsp;synchronouslySetDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getDelegate:delegateQueue:">&ndash;&nbsp;getDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:delegateQueue:">&ndash;&nbsp;setDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">&ndash;&nbsp;synchronouslySetDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Enabled">&ndash;&nbsp;isIPv4Enabled</a></code>
		<span class="tooltip"><p>By default, both IPv4 and IPv6 are enabled.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv4Enabled:">&ndash;&nbsp;setIPv4Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Enabled">&ndash;&nbsp;isIPv6Enabled</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv6Enabled:">&ndash;&nbsp;setIPv6Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4PreferredOverIPv6">&ndash;&nbsp;isIPv4PreferredOverIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setPreferIPv4OverIPv6:">&ndash;&nbsp;setPreferIPv4OverIPv6:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
		<span class="tooltip"><p>User data allows you to associate arbitrary information with the socket.
This data is not used internally by socket in any way.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setUserData:">&ndash;&nbsp;setUserData:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/acceptOnPort:error:">&ndash;&nbsp;acceptOnPort:error:</a></code>
		<span class="tooltip"><p>Tells the socket to begin listening and accepting connections on the given port.
When a connection is accepted, a new instance of GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will be spawned to handle it,
and the socket:didAcceptNewSocket: <a href="#//api/name/delegate">delegate</a> method will be invoked.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/acceptOnInterface:port:error:">&ndash;&nbsp;acceptOnInterface:port:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the
additional option of specifying which interface to listen on.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
		<span class="tooltip"><p>Connects to the given host and port.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:withTimeout:error:</a></code>
		<span class="tooltip"><p>Connects to the given host and port with an optional timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:viaInterface:withTimeout:error:</a></code>
		<span class="tooltip"><p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
		<span class="tooltip"><p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:withTimeout:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:viaInterface:withTimeout:error:">&ndash;&nbsp;connectToAddress:viaInterface:withTimeout:error:</a></code>
		<span class="tooltip"><p>Connects to the given address, using the specified interface and timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnect">&ndash;&nbsp;disconnect</a></code>
		<span class="tooltip"><p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterReading">&ndash;&nbsp;disconnectAfterReading</a></code>
		<span class="tooltip"><p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterWriting">&ndash;&nbsp;disconnectAfterWriting</a></code>
		<span class="tooltip"><p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterReadingAndWriting">&ndash;&nbsp;disconnectAfterReadingAndWriting</a></code>
		<span class="tooltip"><p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isDisconnected">&ndash;&nbsp;isDisconnected</a></code>
		<span class="tooltip"><p>Returns whether the socket is disconnected or connected.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
		<span class="tooltip"><p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedPort">&ndash;&nbsp;connectedPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost">&ndash;&nbsp;localHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort">&ndash;&nbsp;localPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
		<span class="tooltip"><p>Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
		<span class="tooltip"><p>Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isSecure">&ndash;&nbsp;isSecure</a></code>
		<span class="tooltip"><p>Returns whether or not the socket has been secured via SSL/TLS.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:tag:">&ndash;&nbsp;readDataWithTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToLength:withTimeout:tag:">&ndash;&nbsp;readDataToLength:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads the given number of bytes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:tag:">&ndash;&nbsp;readDataToData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfReadReturningTag:bytesDone:total:</a></code>
		<span class="tooltip"><p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeData:withTimeout:tag:">&ndash;&nbsp;writeData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/progressOfWriteReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfWriteReturningTag:bytesDone:total:</a></code>
		<span class="tooltip"><p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/startTLS:">&ndash;&nbsp;startTLS:</a></code>
		<span class="tooltip"><p>Secures the connection using SSL/TLS.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/autoDisconnectOnClosedReadStream">&ndash;&nbsp;autoDisconnectOnClosedReadStream</a></code>
		<span class="tooltip"><p>Traditionally sockets are not closed until the conversation is over.
However, it is technically possible for the remote enpoint to close its write stream.
Our socket would then be notified that there is no more data to be read,
but our socket would still be writeable and the remote endpoint could continue to receive our data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setAutoDisconnectOnClosedReadStream:">&ndash;&nbsp;setAutoDisconnectOnClosedReadStream:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/markSocketQueueTargetQueue:">&ndash;&nbsp;markSocketQueueTargetQueue:</a></code>
		<span class="tooltip"><p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> maintains thread safety by using an internal serial dispatch_queue.
In most cases, the instance creates this queue itself.
However, to allow for maximum flexibility, the internal queue may be passed in the <a href="#//api/name/init">init</a> method.
This allows for some advanced options such as controlling socket priority via target queues.
However, when one begins to use target queues like this, they open the door to some specific deadlock issues.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/unmarkSocketQueueTargetQueue:">&ndash;&nbsp;unmarkSocketQueueTargetQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/performBlock:">&ndash;&nbsp;performBlock:</a></code>
		<span class="tooltip"><p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socketFD">&ndash;&nbsp;socketFD</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket4FD">&ndash;&nbsp;socket4FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket6FD">&ndash;&nbsp;socket6FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readStream">&ndash;&nbsp;readStream</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeStream">&ndash;&nbsp;writeStream</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/enableBackgroundingOnSocket">&ndash;&nbsp;enableBackgroundingOnSocket</a></code>
		<span class="tooltip"><p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sslContext">&ndash;&nbsp;sslContext</a></code>
		<span class="tooltip"><p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/hostFromAddress:">+&nbsp;hostFromAddress:</a></code>
		<span class="tooltip"><p>Extracting host and port information from raw address data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/portFromAddress:">+&nbsp;portFromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getHost:port:fromAddress:">+&nbsp;getHost:port:fromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/CRLFData">+&nbsp;CRLFData</a></code>
		<span class="tooltip"><p>A few common line separators, for use with the readDataToData:&hellip; methods.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/CRData">+&nbsp;CRData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/LFData">+&nbsp;LFData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/ZeroData">+&nbsp;ZeroData</a></code>
		
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/CRData" title="CRData"></a>
	<h3 class="subsubtitle method-title">CRData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)CRData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/CRLFData" title="CRLFData"></a>
	<h3 class="subsubtitle method-title">CRLFData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>A few common line separators, for use with the readDataToData:&hellip; methods.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (NSData *)CRLFData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>A few common line separators, for use with the readDataToData:&hellip; methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/LFData" title="LFData"></a>
	<h3 class="subsubtitle method-title">LFData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)LFData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/ZeroData" title="ZeroData"></a>
	<h3 class="subsubtitle method-title">ZeroData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)ZeroData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getHost:port:fromAddress:" title="getHost:port:fromAddress:"></a>
	<h3 class="subsubtitle method-title">getHost:port:fromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)getHost:(NSString **)<em>hostPtr</em> port:(uint16_t *)<em>portPtr</em> fromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/hostFromAddress:" title="hostFromAddress:"></a>
	<h3 class="subsubtitle method-title">hostFromAddress:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Extracting host and port information from raw address data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (NSString *)hostFromAddress:(NSData *)<em>address</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Extracting host and port information from raw address data.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/portFromAddress:" title="portFromAddress:"></a>
	<h3 class="subsubtitle method-title">portFromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (uint16_t)portFromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
					</div>
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/acceptOnInterface:port:error:" title="acceptOnInterface:port:error:"></a>
	<h3 class="subsubtitle method-title">acceptOnInterface:port:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the
additional option of specifying which interface to listen on.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnInterface:(NSString *)<em>interface</em> port:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the
additional option of specifying which interface to listen on.</p>

<p>For example, you could specify that the socket should only accept connections over ethernet,
and not other interfaces such as wifi.</p>

<p>The interface may be specified by name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or by IP address (e.g. &ldquo;192.168.4.34&rdquo;).
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept connections from the local machine.</p>

<p>You can see the list of interfaces via the command line utility &ldquo;ifconfig&rdquo;,
or programmatically via the getifaddrs() function.</p>

<p>To accept connections on any interface pass nil, or simply use the <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/acceptOnPort:error:" title="acceptOnPort:error:"></a>
	<h3 class="subsubtitle method-title">acceptOnPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Tells the socket to begin listening and accepting connections on the given port.
When a connection is accepted, a new instance of GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will be spawned to handle it,
and the socket:didAcceptNewSocket: <a href="#//api/name/delegate">delegate</a> method will be invoked.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Tells the socket to begin listening and accepting connections on the given port.
When a connection is accepted, a new instance of GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will be spawned to handle it,
and the socket:didAcceptNewSocket: <a href="#//api/name/delegate">delegate</a> method will be invoked.</p>

<p>The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/autoDisconnectOnClosedReadStream" title="autoDisconnectOnClosedReadStream"></a>
	<h3 class="subsubtitle method-title">autoDisconnectOnClosedReadStream</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Traditionally sockets are not closed until the conversation is over.
However, it is technically possible for the remote enpoint to close its write stream.
Our socket would then be notified that there is no more data to be read,
but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)autoDisconnectOnClosedReadStream</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Traditionally sockets are not closed until the conversation is over.
However, it is technically possible for the remote enpoint to close its write stream.
Our socket would then be notified that there is no more data to be read,
but our socket would still be writeable and the remote endpoint could continue to receive our data.</p>

<p>The argument for this confusing functionality stems from the idea that a client could shut down its
write stream after sending a request to the server, thus notifying the server there are to be no further requests.
In practice, however, this technique did little to help server developers.</p>

<p>To make matters worse, from a TCP perspective there is no way to tell the difference from a read stream close
and a full socket close. They both result in the TCP stack receiving a FIN packet. The only way to tell
is by continuing to write to the socket. If it was only a read stream close, then writes will continue to work.
Otherwise an error will be occur shortly (when the remote end sends us a RST packet).</p>

<p>In addition to the technical challenges and confusion, many high level socket/stream API&rsquo;s provide
no support for dealing with the problem. If the read stream is closed, the API immediately declares the
socket to be closed, and shuts down the write stream as well. In fact, this is what Apple&rsquo;s CFStream API does.
It might sound like poor design at first, but in fact it simplifies development.</p>

<p>The vast majority of the time if the read stream is closed it&rsquo;s because the remote endpoint closed its socket.
Thus it actually makes sense to close the socket at this point.
And in fact this is what most networking developers want and expect to happen.
However, if you are writing a server that interacts with a plethora of clients,
you might encounter a client that uses the discouraged technique of shutting down its write stream.
If this is the case, you can set this property to NO,
and make use of the socketDidCloseReadStream <a href="#//api/name/delegate">delegate</a> method.</p>

<p>The default value is YES.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  &ndash;> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa &ndash;> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>This method invokes connectToAdd</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:viaInterface:withTimeout:error:" title="connectToAddress:viaInterface:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:viaInterface:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given address, using the specified interface and timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> viaInterface:(NSString *)<em>interface</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given address, using the specified interface and timeout.</p>

<p>The address is specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  &ndash;> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa &ndash;> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).
The interface may also be used to specify the local port (see below).</p>

<p>The timeout is optional. To not time out use a negative time interval.</p>

<p>This method will return NO if an error is detected, and set the error pointer (if one was given).
Possible errors would be a nil host, invalid interface, or socket is already connected.</p>

<p>If no errors are detected, this method will start a background connect operation and immediately return YES.
The <a href="#//api/name/delegate">delegate</a> callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>

<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing.
All read/write operations will be queued, and upon socket connection,
the operations will be dequeued and processed in order.</p>

<p>The interface may optionally contain a port number at the end of the string, separated by a colon.
This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end)
To specify both interface and local port: &ldquo;en1:8082&rdquo; or &ldquo;192.168.4.35:2424&rdquo;.
To specify only local port: &ldquo;:8082&rdquo;.
Please note this is an advanced feature, and is somewhat hidden on purpose.
You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection.
If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere.
Local ports do NOT need to match remote ports. In fact, they almost never do.
This feature is here for networking professionals using very advanced techniques.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:withTimeout:error:" title="connectToAddress:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host and port.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host and port.</p>

<p>This method invokes <a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">connectToHost:onPort:viaInterface:withTimeout:error:</a>
and uses the default interface, and no timeout.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:viaInterface:withTimeout:error:" title="connectToHost:onPort:viaInterface:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:viaInterface:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> viaInterface:(NSString *)<em>interface</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host &amp; port, via the optional interface, with an optional timeout.</p>

<p>The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).
The host may also be the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify connecting
to a service on the local machine.</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).
The interface may also be used to specify the local port (see below).</p>

<p>To not time out use a negative time interval.</p>

<p>This method will return NO if an error is detected, and set the error pointer (if one was given).
Possible errors would be a nil host, invalid interface, or socket is already connected.</p>

<p>If no errors are detected, this method will start a background connect operation and immediately return YES.
The <a href="#//api/name/delegate">delegate</a> callbacks are used to notify you when the socket connects, or if the host was unreachable.</p>

<p>Since this class supports queued reads and writes, you can immediately start reading and/or writing.
All read/write operations will be queued, and upon socket connection,
the operations will be dequeued and processed in order.</p>

<p>The interface may optionally contain a port number at the end of the string, separated by a colon.
This allows you to specify the local port that should be used for the outgoing connection. (read paragraph to end)
To specify both interface and local port: &ldquo;en1:8082&rdquo; or &ldquo;192.168.4.35:2424&rdquo;.
To specify only local port: &ldquo;:8082&rdquo;.
Please note this is an advanced feature, and is somewhat hidden on purpose.
You should understand that 99.999% of the time you should NOT specify the local port for an outgoing connection.
If you think you need to, there is a very good chance you have a fundamental misunderstanding somewhere.
Local ports do NOT need to match remote ports. In fact, they almost never do.
This feature is here for networking professionals using very advanced techniques.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:withTimeout:error:" title="connectToHost:onPort:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host and port with an optional timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host and port with an optional timeout.</p>

<p>This method invokes <a href="#//api/name/connectToHost:onPort:viaInterface:withTimeout:error:">connectToHost:onPort:viaInterface:withTimeout:error:</a> and uses the default interface.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="subsubtitle method-title">connectedAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</p>

<p>See also the <a href="#//api/name/connectedHost">connectedHost</a>, <a href="#//api/name/connectedPort">connectedPort</a>, <a href="#//api/name/localHost">localHost</a> and <a href="#//api/name/localPort">localPort</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="subsubtitle method-title">connectedHost</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedPort" title="connectedPort"></a>
	<h3 class="subsubtitle method-title">connectedPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)connectedPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="subsubtitle method-title">delegate</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegateQueue" title="delegateQueue"></a>
	<h3 class="subsubtitle method-title">delegateQueue</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (dispatch_queue_t)delegateQueue</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnect" title="disconnect"></a>
	<h3 class="subsubtitle method-title">disconnect</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnect</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects immediately (synchronously). Any pending reads or writes are dropped.</p>

<p>If the socket is not already disconnected, an invocation to the socketDidDisconnect:withError: delegate method
will be queued onto the delegateQueue asynchronously (behind any previously queued delegate methods).
In other words, the disconnected delegate method will be invoked sometime shortly after this method returns.</p>

<p>Please note the recommended way of releasing a GCDAsyncSocket instance (e.g. in a dealloc method)
[asyncSocket setDelegate:nil];
[asyncSocket disconnect];
[asyncSocket release];</p>

<p>If you plan on disconnecting the socket, and then immediately asking it to connect again,
you&rsquo;ll likely want to do so like this:
[asyncSocket setDelegate:nil];
[asyncSocket disconnect];
[asyncSocket setDelegate:self];
[asyncSocket connect&hellip;];</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterReading" title="disconnectAfterReading"></a>
	<h3 class="subsubtitle method-title">disconnectAfterReading</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReading</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterReadingAndWriting" title="disconnectAfterReadingAndWriting"></a>
	<h3 class="subsubtitle method-title">disconnectAfterReadingAndWriting</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReadingAndWriting</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterWriting" title="disconnectAfterWriting"></a>
	<h3 class="subsubtitle method-title">disconnectAfterWriting</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterWriting</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/enableBackgroundingOnSocket" title="enableBackgroundingOnSocket"></a>
	<h3 class="subsubtitle method-title">enableBackgroundingOnSocket</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)enableBackgroundingOnSocket</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Configures the socket to allow it to operate when the iOS application has been backgrounded.
In other words, this method creates a read &amp; write stream, and invokes:</p>

<p>CFReadStreamSetProperty(<a href="#//api/name/readStream">readStream</a>, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);
CFWriteStreamSetProperty(<a href="#//api/name/writeStream">writeStream</a>, kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP);</p>

<p>Returns YES if successful, NO otherwise.</p>

<p>Note: Apple does not officially support backgrounding server sockets.
That is, if your socket is accepting incoming connections, Apple does not officially support
allowing iOS applications to accept incoming connections while an app is backgrounded.</p>

<p>Example usage:</p>

<ul>
<li>(void)socket:(GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> <em>)sock didConnectToHost:(NSString </em>)host port:(uint16_t)port
{
[asyncSocket performBlock:^{
[asyncSocket enableBackgroundingOnSocket];
}];
}</li>
</ul>

	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/getDelegate:delegateQueue:" title="getDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">getDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)getDelegate:(id *)<em>delegatePtr</em> delegateQueue:(dispatch_queue_t *)<em>delegateQueuePtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="subsubtitle method-title">init</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)init</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>

<p>You MUST set a <a href="#//api/name/delegate">delegate</a> AND <a href="#//api/name/delegate">delegate</a> dispatch queue before attempting to
use the socket, or you will get an error.</p>

<p>The socket queue is optional.
If you pass NULL, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically create it&rsquo;s own socket queue.
If you choose to provide a socket queue, the socket queue must not be a concurrent queue.
If you choose to provide a socket queue, and the socket queue has a configured target queue,
then please see the discussion for the method markSocketQueueTargetQueue.</p>

<p>The <a href="#//api/name/delegate">delegate</a> queue and socket queue can optionally be the same.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:" title="initWithDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:socketQueue:" title="initWithDelegate:delegateQueue:socketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:socketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em> socketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithSocketQueue:" title="initWithSocketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithSocketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithSocketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="subsubtitle method-title">isConnected</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isDisconnected" title="isDisconnected"></a>
	<h3 class="subsubtitle method-title">isDisconnected</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether the socket is disconnected or connected.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isDisconnected</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether the socket is disconnected or connected.</p>

<p>A disconnected socket may be recycled.
That is, it can used again for connecting or listening.</p>

<p>If a socket is in the process of connecting, it may be neither disconnected nor connected.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="subsubtitle method-title">isIPv4</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Enabled" title="isIPv4Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv4Enabled</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>By default, both IPv4 and IPv6 are enabled.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Enabled</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>By default, both IPv4 and IPv6 are enabled.</p>

<p>For accepting incoming connections, this means GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> automatically supports both protocols,
and can simulataneously accept incoming connections on either protocol.</p>

<p>For outgoing connections, this means GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> can connect to remote hosts running either protocol.
If a DNS lookup returns only IPv4 results, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically use IPv4.
If a DNS lookup returns only IPv6 results, GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> will automatically use IPv6.
If a DNS lookup returns both IPv4 and IPv6 results, the preferred protocol will be chosen.
By default, the preferred protocol is IPv4, but may be configured as desired.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4PreferredOverIPv6" title="isIPv4PreferredOverIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv4PreferredOverIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4PreferredOverIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Enabled" title="isIPv6Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv6Enabled</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6Enabled</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isSecure" title="isSecure"></a>
	<h3 class="subsubtitle method-title">isSecure</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not the socket has been secured via SSL/TLS.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isSecure</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not the socket has been secured via SSL/TLS.</p>

<p>See also the startTLS method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="subsubtitle method-title">localAddress</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost" title="localHost"></a>
	<h3 class="subsubtitle method-title">localHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort" title="localPort"></a>
	<h3 class="subsubtitle method-title">localPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/markSocketQueueTargetQueue:" title="markSocketQueueTargetQueue:"></a>
	<h3 class="subsubtitle method-title">markSocketQueueTargetQueue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> maintains thread safety by using an internal serial dispatch_queue.
In most cases, the instance creates this queue itself.
However, to allow for maximum flexibility, the internal queue may be passed in the <a href="#//api/name/init">init</a> method.
This allows for some advanced options such as controlling socket priority via target queues.
However, when one begins to use target queues like this, they open the door to some specific deadlock issues.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)markSocketQueueTargetQueue:(dispatch_queue_t)<em>socketQueuesPreConfiguredTargetQueue</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> maintains thread safety by using an internal serial dispatch_queue.
In most cases, the instance creates this queue itself.
However, to allow for maximum flexibility, the internal queue may be passed in the <a href="#//api/name/init">init</a> method.
This allows for some advanced options such as controlling socket priority via target queues.
However, when one begins to use target queues like this, they open the door to some specific deadlock issues.</p>

<p>For example, imagine there are 2 queues:
dispatch_queue_t socketQueue;
dispatch_queue_t socketTargetQueue;</p>

<p>If you do this (pseudo-code):
socketQueue.targetQueue = socketTargetQueue;</p>

<p>Then all socketQueue operations will actually get run on the given socketTargetQueue.
This is fine and works great in most situations.
But if you run code directly from within the socketTargetQueue that accesses the socket,
you could potentially get deadlock. Imagine the following code:</p>

<ul>
<li>(BOOL)socketHasSomething
{
__block BOOL result = NO;
dispatch_block_t block = ^{
result = [self someInternalMethodToBeRunOnlyOnSocketQueue];
}
if (is_executing_on_queue(socketQueue))
block();
else
dispatch_sync(socketQueue, block);</li>
</ul>


<p>return result;
}</p>

<p>What happens if you call this method from the socketTargetQueue? The result is deadlock.
This is because the GCD API offers no mechanism to discover a queue&rsquo;s targetQueue.
Thus we have no idea if our socketQueue is configured with a targetQueue.
If we had this information, we could easily avoid deadlock.
But, since these API&rsquo;s are missing or unfeasible, you&rsquo;ll have to explicitly set it.</p>

<p>IF you pass a socketQueue via the <a href="#//api/name/init">init</a> method,
AND you&rsquo;ve configured the passed socketQueue with a targetQueue,
THEN you should pass the end queue in the target hierarchy.</p>

<p>For example, consider the following queue hierarchy:
socketQueue &ndash;> ipQueue &ndash;> moduleQueue</p>

<p>This example demonstrates priority shaping within some server.
All incoming client connections from the same IP address are executed on the same target queue.
And all connections for a particular module are executed on the same target queue.
Thus, the priority of all networking for the entire module can be changed on the fly.
Additionally, networking traffic from a single IP cannot monopolize the module.</p>

<p>Here&rsquo;s how you would accomplish something like that:
&ndash; (dispatch_queue_t)newSocketQueueForConnectionFromAddress:(NSData <em>)address onSocket:(GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> </em>)sock
{
dispatch_queue_t socketQueue = dispatch_queue_create(&ldquo;&rdquo;, NULL);
dispatch_queue_t ipQueue = [self ipQueueForAddress:address];</p>

<p>dispatch_set_target_queue(socketQueue, ipQueue);
dispatch_set_target_queue(iqQueue, moduleQueue);</p>

<p>return socketQueue;
}
&ndash; (void)socket:(GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> <em>)sock didAcceptNewSocket:(GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> </em>)newSocket
{
[clientConnections addObject:newSocket];
[newSocket markSocketQueueTargetQueue:moduleQueue];
}</p>

<p>Note: This workaround is ONLY needed if you intend to execute code directly on the ipQueue or moduleQueue.
This is often NOT the case, as such queues are used solely for execution shaping.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/performBlock:" title="performBlock:"></a>
	<h3 class="subsubtitle method-title">performBlock:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)performBlock:(dispatch_block_t)<em>block</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>

<p>For example, the socket file descriptor.
File descriptors are simply integers which reference an index in the per-process file table.
However, when one requests a new file descriptor (by opening a file or socket),
the file descriptor returned is guaranteed to be the lowest numbered unused descriptor.
So if we&rsquo;re not careful, the following could be possible:</p>

<ul>
<li>Thread A invokes a method which returns the socket&rsquo;s file descriptor.</li>
<li>The socket is closed via the socket&rsquo;s internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket&rsquo;s FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>


<p>In addition to this, other variables are not actually objects,
and thus cannot be retained/released or even autoreleased.
An example is the <a href="#//api/name/sslContext">sslContext</a>, of type SSLContextRef, which is actually a malloc&rsquo;d struct.</p>

<p>Although there are internal variables that make it difficult to maintain thread-safety,
it is important to provide access to these variables
to ensure this class can be used in a wide array of environments.
This method helps to accomplish this by invoking the current block on the socket&rsquo;s internal queue.
The methods below can be invoked from within the block to access
those generally thread-unsafe internal variables in a thread-safe manner.
The given block will be invoked synchronously on the socket&rsquo;s internal queue.</p>

<p>If you save references to any protected variables and use them outside the block, you do so at your own peril.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/progressOfReadReturningTag:bytesDone:total:" title="progressOfReadReturningTag:bytesDone:total:"></a>
	<h3 class="subsubtitle method-title">progressOfReadReturningTag:bytesDone:total:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (float)progressOfReadReturningTag:(long *)<em>tagPtr</em> bytesDone:(NSUInteger *)<em>donePtr</em> total:(NSUInteger *)<em>totalPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/progressOfWriteReturningTag:bytesDone:total:" title="progressOfWriteReturningTag:bytesDone:total:"></a>
	<h3 class="subsubtitle method-title">progressOfWriteReturningTag:bytesDone:total:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (float)progressOfWriteReturningTag:(long *)<em>tagPtr</em> bytesDone:(NSUInteger *)<em>donePtr</em> total:(NSUInteger *)<em>totalPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).
The parameters &ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If maxLength is zero, no length restriction is enforced.
Otherwise if maxLength bytes are read without completing the read,
it is treated similarly to a timeout &ndash; the socket is closed with a GCDAsyncSocketReadMaxedOutError.
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass a maxLength parameter that is less than the length of the data (separator) parameter,
the method will do nothing (except maybe print a warning), and the delegate will not be called.
If the bufferOffset is greater than the length of the given buffer,
the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer via
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as
part of the data between separators.
For example, imagine you want to send several small documents over a socket.
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
In this particular example, it would be better to use a protocol similar to HTTP with
a header that includes the length of the document.
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.
For performance reasons, the socket will retain it, not copy it.
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,
the method will do nothing (except maybe print a warning), and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer via
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as
part of the data between separators.
For example, imagine you want to send several small documents over a socket.
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
In this particular example, it would be better to use a protocol similar to HTTP with
a header that includes the length of the document.
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.
For performance reasons, the socket will retain it, not copy it.
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:maxLength:tag:" title="readDataToData:withTimeout:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If maxLength is zero, no length restriction is enforced.
Otherwise if maxLength bytes are read without completing the read,
it is treated similarly to a timeout &ndash; the socket is closed with a GCDAsyncSocketReadMaxedOutError.
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,
the method will do nothing (except maybe print a warning), and the <a href="#//api/name/delegate">delegate</a> will not be called.
If you pass a maxLength parameter that is less than the length of the data parameter,
the method will do nothing (except maybe print a warning), and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as
part of the data between separators.
For example, imagine you want to send several small documents over a socket.
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
In this particular example, it would be better to use a protocol similar to HTTP with
a header that includes the length of the document.
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.
For performance reasons, the socket will retain it, not copy it.
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:tag:" title="readDataToData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,
the method will do nothing (except maybe print a warning), and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.
If you&rsquo;re developing your own custom protocol, be sure your separator can not occur naturally as
part of the data between separators.
For example, imagine you want to send several small documents over a socket.
Using CRLF as a separator is likely unwise, as a CRLF could easily exist within the documents.
In this particular example, it would be better to use a protocol similar to HTTP with
a header that includes the length of the document.
Also be careful that your separator cannot occur naturally as part of the encoding for a character.</p>

<p>The given data (separator) parameter should be immutable.
For performance reasons, the socket will retain it, not copy it.
So if it is immutable, don&rsquo;t modify it while the socket is using it.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:" title="readDataToLength:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToLength:withTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the length is 0, this method does nothing and the delegate is not called.
If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer via
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:tag:" title="readDataToLength:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToLength:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the given number of bytes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the given number of bytes.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataWithTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, a buffer will automatically be created for you.
If maxLength is zero, no length restriction is enforced.</p>

<p>If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer  via
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:" title="readDataWithTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.
If the buffer if nil, the socket will create a buffer for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,
the method will do nothing, and the delegate will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while the socket is using it.
After completion, the data returned in socket:didReadData:withTag: will be a subset of the given buffer.
That is, it will reference the bytes that were appended to the given buffer via
the method [NSData dataWithBytesNoCopy:length:freeWhenDone:NO].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:tag:" title="readDataWithTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readStream" title="readStream"></a>
	<h3 class="subsubtitle method-title">readStream</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (CFReadStreamRef)readStream</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s internal CFReadStream/CFWriteStream.</p>

<p>These streams are only used as workarounds for specific iOS shortcomings:</p>

<ul>
<li><p>Apple has decided to keep the SecureTransport framework private is iOS.
This means the only supplied way to do SSL/TLS is via CFStream or some other API layered on top of it.
Thus, in order to provide SSL/TLS support on iOS we are forced to rely on CFStream,
instead of the preferred and faster and more powerful SecureTransport.</p></li>
<li><p>If a socket doesn&rsquo;t have backgrounding enabled, and that socket is closed while the app is backgrounded,
Apple only bothers to notify us via the CFStream API.
The faster and more powerful GCD API isn&rsquo;t notified properly in this case.</p></li>
</ul>


<p>See also: (BOOL)<a href="#//api/name/enableBackgroundingOnSocket">enableBackgroundingOnSocket</a></p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setAutoDisconnectOnClosedReadStream:" title="setAutoDisconnectOnClosedReadStream:"></a>
	<h3 class="subsubtitle method-title">setAutoDisconnectOnClosedReadStream:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setAutoDisconnectOnClosedReadStream:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:" title="setDelegate:"></a>
	<h3 class="subsubtitle method-title">setDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:delegateQueue:" title="setDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegateQueue:" title="setDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv4Enabled:" title="setIPv4Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv4Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv4Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv6Enabled:" title="setIPv6Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv6Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv6Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setPreferIPv4OverIPv6:" title="setPreferIPv4OverIPv6:"></a>
	<h3 class="subsubtitle method-title">setPreferIPv4OverIPv6:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setPreferIPv4OverIPv6:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setUserData:" title="setUserData:"></a>
	<h3 class="subsubtitle method-title">setUserData:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setUserData:(id)<em>arbitraryUserData</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket4FD" title="socket4FD"></a>
	<h3 class="subsubtitle method-title">socket4FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket4FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket6FD" title="socket6FD"></a>
	<h3 class="subsubtitle method-title">socket6FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket6FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socketFD" title="socketFD"></a>
	<h3 class="subsubtitle method-title">socketFD</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (int)socketFD</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s file descriptor(s).
If the socket is a server socket (is accepting incoming connections),
it might actually have multiple internal socket file descriptors &ndash; one for IPv4 and one for IPv6.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sslContext" title="sslContext"></a>
	<h3 class="subsubtitle method-title">sslContext</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (SSLContextRef)sslContext</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s SSLContext, if SSL/TLS has been started on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/startTLS:" title="startTLS:"></a>
	<h3 class="subsubtitle method-title">startTLS:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Secures the connection using SSL/TLS.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)startTLS:(NSDictionary *)<em>tlsSettings</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Secures the connection using SSL/TLS.</p>

<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes
are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing
the upgrade to TLS at the same time, without having to wait for the write to finish.
Any reads or writes scheduled after this method is called will occur over the secured connection.</p>

<p>The possible keys and values for the TLS settings are well documented.
Standard keys are:</p>

<ul>
<li>kCFStreamSSLLevel</li>
<li>kCFStreamSSLAllowsExpiredCertificates</li>
<li>kCFStreamSSLAllowsExpiredRoots</li>
<li>kCFStreamSSLAllowsAnyRoot</li>
<li>kCFStreamSSLValidatesCertificateChain</li>
<li>kCFStreamSSLPeerName</li>
<li>kCFStreamSSLCertificates</li>
<li>kCFStreamSSLIsServer</li>
</ul>


<p>If SecureTransport is available on iOS:</p>

<ul>
<li>GCDAsyncSocketSSLCipherSuites</li>
<li>GCDAsyncSocketSSLProtocolVersionMin</li>
<li>GCDAsyncSocketSSLProtocolVersionMax</li>
</ul>


<p>If SecureTransport is available on Mac OS X:</p>

<ul>
<li>GCDAsyncSocketSSLCipherSuites</li>
<li>GCDAsyncSocketSSLDiffieHellmanParameters;</li>
</ul>


<p>Please refer to Apple&rsquo;s documentation for associated values, as well as other possible keys.</p>

<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>

<p>The default settings will check to make sure the remote party&rsquo;s certificate is signed by a
trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.
However it will not verify the name on the certificate unless you
give it a name to verify against via the kCFStreamSSLPeerName key.
The security implications of this are important to understand.
Imagine you are attempting to create a secure connection to MySecureServer.com,
but your socket gets directed to MaliciousServer.com because of a hacked DNS server.
If you simply use the default settings, and MaliciousServer.com has a valid certificate,
the default settings will not detect any problems since the certificate is valid.
To properly secure your connection in this particular scenario you
should set the kCFStreamSSLPeerName property to &ldquo;MySecureServer.com&rdquo;.
If you do not know the peer name of the remote host in advance (for example, you&rsquo;re not sure
if it will be &ldquo;domain.com&rdquo; or &ldquo;www.domain.com&rdquo;), then you can use the default settings to validate the
certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured.
The X509Certificate class is part of the Cocoa<a href="../Classes/AsyncSocket.html">AsyncSocket</a> open source project.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:" title="synchronouslySetDelegate:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:delegateQueue:" title="synchronouslySetDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegateQueue:" title="synchronouslySetDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/unmarkSocketQueueTargetQueue:" title="unmarkSocketQueueTargetQueue:"></a>
	<h3 class="subsubtitle method-title">unmarkSocketQueueTargetQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)unmarkSocketQueueTargetQueue:(dispatch_queue_t)<em>socketQueuesPreviouslyConfiguredTargetQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="subsubtitle method-title">userData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally by socket in any way.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)userData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally by socket in any way.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/writeData:withTimeout:tag:" title="writeData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">writeData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)writeData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>

<p>If you pass in nil or zero-length data, this method does nothing and the <a href="#//api/name/delegate">delegate</a> will not be called.
If the timeout value is negative, the write operation will not use a timeout.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is writing it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method
socket:didWriteDataWithTag: is invoked signifying that this particular write operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncSocket.html">AsyncSocket</a> does NOT copy the data. It simply retains it.
This is for performance reasons. Often times, if NSMutableData is passed, it is because
a request/response was built up in memory. Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes writing the bytes (which is NOT immediately after this method returns, but rather at a later time
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/writeStream" title="writeStream"></a>
	<h3 class="subsubtitle method-title">writeStream</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFWriteStreamRef)writeStream</code></div>

    
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2012 Dustin Voss and Robbie Hanson. All rights reserved. (Last updated: 2012-11-06)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 840)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>