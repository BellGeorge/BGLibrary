<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>GCDAsyncUdpSocket Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<meta name="viewport" content="width=550" />
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 840)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">CocoaAsyncSocket 0.0.1 </a></h1>
				<a id="developerHome" href="../index.html">Dustin Voss and Robbie Hanson</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">GCDAsyncUdpSocket Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/familyFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ familyFromAddress:</option>
	
	<option value="//api/name/getHost:port:family:fromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ getHost:port:family:fromAddress:</option>
	
	<option value="//api/name/getHost:port:fromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ getHost:port:fromAddress:</option>
	
	<option value="//api/name/hostFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ hostFromAddress:</option>
	
	<option value="//api/name/isIPv4Address:">&nbsp;&nbsp;&nbsp;&nbsp;+ isIPv4Address:</option>
	
	<option value="//api/name/isIPv6Address:">&nbsp;&nbsp;&nbsp;&nbsp;+ isIPv6Address:</option>
	
	<option value="//api/name/portFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ portFromAddress:</option>
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/beginReceiving:">&nbsp;&nbsp;&nbsp;&nbsp;- beginReceiving:</option>
	
	<option value="//api/name/bindToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- bindToAddress:error:</option>
	
	<option value="//api/name/bindToPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- bindToPort:error:</option>
	
	<option value="//api/name/bindToPort:interface:error:">&nbsp;&nbsp;&nbsp;&nbsp;- bindToPort:interface:error:</option>
	
	<option value="//api/name/close">&nbsp;&nbsp;&nbsp;&nbsp;- close</option>
	
	<option value="//api/name/closeAfterSending">&nbsp;&nbsp;&nbsp;&nbsp;- closeAfterSending</option>
	
	<option value="//api/name/connectToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:error:</option>
	
	<option value="//api/name/connectToHost:onPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:error:</option>
	
	<option value="//api/name/connectedAddress">&nbsp;&nbsp;&nbsp;&nbsp;- connectedAddress</option>
	
	<option value="//api/name/connectedHost">&nbsp;&nbsp;&nbsp;&nbsp;- connectedHost</option>
	
	<option value="//api/name/connectedPort">&nbsp;&nbsp;&nbsp;&nbsp;- connectedPort</option>
	
	<option value="//api/name/delegate">&nbsp;&nbsp;&nbsp;&nbsp;- delegate</option>
	
	<option value="//api/name/delegateQueue">&nbsp;&nbsp;&nbsp;&nbsp;- delegateQueue</option>
	
	<option value="//api/name/enableBroadcast:error:">&nbsp;&nbsp;&nbsp;&nbsp;- enableBroadcast:error:</option>
	
	<option value="//api/name/getDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- getDelegate:delegateQueue:</option>
	
	<option value="//api/name/init">&nbsp;&nbsp;&nbsp;&nbsp;- init</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:socketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:socketQueue:</option>
	
	<option value="//api/name/initWithSocketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithSocketQueue:</option>
	
	<option value="//api/name/isClosed">&nbsp;&nbsp;&nbsp;&nbsp;- isClosed</option>
	
	<option value="//api/name/isConnected">&nbsp;&nbsp;&nbsp;&nbsp;- isConnected</option>
	
	<option value="//api/name/isIPVersionNeutral">&nbsp;&nbsp;&nbsp;&nbsp;- isIPVersionNeutral</option>
	
	<option value="//api/name/isIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4</option>
	
	<option value="//api/name/isIPv4Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4Enabled</option>
	
	<option value="//api/name/isIPv4Preferred">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4Preferred</option>
	
	<option value="//api/name/isIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6</option>
	
	<option value="//api/name/isIPv6Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6Enabled</option>
	
	<option value="//api/name/isIPv6Preferred">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6Preferred</option>
	
	<option value="//api/name/joinMulticastGroup:error:">&nbsp;&nbsp;&nbsp;&nbsp;- joinMulticastGroup:error:</option>
	
	<option value="//api/name/joinMulticastGroup:onInterface:error:">&nbsp;&nbsp;&nbsp;&nbsp;- joinMulticastGroup:onInterface:error:</option>
	
	<option value="//api/name/leaveMulticastGroup:error:">&nbsp;&nbsp;&nbsp;&nbsp;- leaveMulticastGroup:error:</option>
	
	<option value="//api/name/leaveMulticastGroup:onInterface:error:">&nbsp;&nbsp;&nbsp;&nbsp;- leaveMulticastGroup:onInterface:error:</option>
	
	<option value="//api/name/localAddress">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress</option>
	
	<option value="//api/name/localAddress_IPv4">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress_IPv4</option>
	
	<option value="//api/name/localAddress_IPv6">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress_IPv6</option>
	
	<option value="//api/name/localHost">&nbsp;&nbsp;&nbsp;&nbsp;- localHost</option>
	
	<option value="//api/name/localHost_IPv4">&nbsp;&nbsp;&nbsp;&nbsp;- localHost_IPv4</option>
	
	<option value="//api/name/localHost_IPv6">&nbsp;&nbsp;&nbsp;&nbsp;- localHost_IPv6</option>
	
	<option value="//api/name/localPort">&nbsp;&nbsp;&nbsp;&nbsp;- localPort</option>
	
	<option value="//api/name/localPort_IPv4">&nbsp;&nbsp;&nbsp;&nbsp;- localPort_IPv4</option>
	
	<option value="//api/name/localPort_IPv6">&nbsp;&nbsp;&nbsp;&nbsp;- localPort_IPv6</option>
	
	<option value="//api/name/maxReceiveIPv4BufferSize">&nbsp;&nbsp;&nbsp;&nbsp;- maxReceiveIPv4BufferSize</option>
	
	<option value="//api/name/maxReceiveIPv6BufferSize">&nbsp;&nbsp;&nbsp;&nbsp;- maxReceiveIPv6BufferSize</option>
	
	<option value="//api/name/pauseReceiving">&nbsp;&nbsp;&nbsp;&nbsp;- pauseReceiving</option>
	
	<option value="//api/name/performBlock:">&nbsp;&nbsp;&nbsp;&nbsp;- performBlock:</option>
	
	<option value="//api/name/readStream">&nbsp;&nbsp;&nbsp;&nbsp;- readStream</option>
	
	<option value="//api/name/receiveOnce:">&nbsp;&nbsp;&nbsp;&nbsp;- receiveOnce:</option>
	
	<option value="//api/name/sendData:toAddress:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- sendData:toAddress:withTimeout:tag:</option>
	
	<option value="//api/name/sendData:toHost:port:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- sendData:toHost:port:withTimeout:tag:</option>
	
	<option value="//api/name/sendData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- sendData:withTimeout:tag:</option>
	
	<option value="//api/name/setDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:</option>
	
	<option value="//api/name/setDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:delegateQueue:</option>
	
	<option value="//api/name/setDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegateQueue:</option>
	
	<option value="//api/name/setIPVersionNeutral">&nbsp;&nbsp;&nbsp;&nbsp;- setIPVersionNeutral</option>
	
	<option value="//api/name/setIPv4Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv4Enabled:</option>
	
	<option value="//api/name/setIPv6Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv6Enabled:</option>
	
	<option value="//api/name/setMaxReceiveIPv4BufferSize:">&nbsp;&nbsp;&nbsp;&nbsp;- setMaxReceiveIPv4BufferSize:</option>
	
	<option value="//api/name/setMaxReceiveIPv6BufferSize:">&nbsp;&nbsp;&nbsp;&nbsp;- setMaxReceiveIPv6BufferSize:</option>
	
	<option value="//api/name/setPreferIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- setPreferIPv4</option>
	
	<option value="//api/name/setPreferIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- setPreferIPv6</option>
	
	<option value="//api/name/setReceiveFilter:withQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setReceiveFilter:withQueue:</option>
	
	<option value="//api/name/setReceiveFilter:withQueue:isAsynchronous:">&nbsp;&nbsp;&nbsp;&nbsp;- setReceiveFilter:withQueue:isAsynchronous:</option>
	
	<option value="//api/name/setSendFilter:withQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setSendFilter:withQueue:</option>
	
	<option value="//api/name/setSendFilter:withQueue:isAsynchronous:">&nbsp;&nbsp;&nbsp;&nbsp;- setSendFilter:withQueue:isAsynchronous:</option>
	
	<option value="//api/name/setUserData:">&nbsp;&nbsp;&nbsp;&nbsp;- setUserData:</option>
	
	<option value="//api/name/socket4FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket4FD</option>
	
	<option value="//api/name/socket6FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket6FD</option>
	
	<option value="//api/name/socketFD">&nbsp;&nbsp;&nbsp;&nbsp;- socketFD</option>
	
	<option value="//api/name/synchronouslySetDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:</option>
	
	<option value="//api/name/synchronouslySetDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:delegateQueue:</option>
	
	<option value="//api/name/synchronouslySetDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegateQueue:</option>
	
	<option value="//api/name/userData">&nbsp;&nbsp;&nbsp;&nbsp;- userData</option>
	
	<option value="//api/name/writeStream">&nbsp;&nbsp;&nbsp;&nbsp;- writeStream</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/familyFromAddress:">familyFromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getHost:port:family:fromAddress:">getHost:port:family:fromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getHost:port:fromAddress:">getHost:port:fromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/hostFromAddress:">hostFromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Address:">isIPv4Address:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Address:">isIPv6Address:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/portFromAddress:">portFromAddress:</a></span></li>
	
</ul></li>



<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/beginReceiving:">beginReceiving:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bindToAddress:error:">bindToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bindToPort:error:">bindToPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bindToPort:interface:error:">bindToPort:interface:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/close">close</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/closeAfterSending">closeAfterSending</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedAddress">connectedAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedHost">connectedHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedPort">connectedPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegate">delegate</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegateQueue">delegateQueue</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/enableBroadcast:error:">enableBroadcast:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getDelegate:delegateQueue:">getDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/init">init</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:">initWithDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">initWithDelegate:delegateQueue:socketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithSocketQueue:">initWithSocketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isClosed">isClosed</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isConnected">isConnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPVersionNeutral">isIPVersionNeutral</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4">isIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Enabled">isIPv4Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Preferred">isIPv4Preferred</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6">isIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Enabled">isIPv6Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Preferred">isIPv6Preferred</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/joinMulticastGroup:error:">joinMulticastGroup:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/joinMulticastGroup:onInterface:error:">joinMulticastGroup:onInterface:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/leaveMulticastGroup:error:">leaveMulticastGroup:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/leaveMulticastGroup:onInterface:error:">leaveMulticastGroup:onInterface:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress">localAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress_IPv4">localAddress_IPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress_IPv6">localAddress_IPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost">localHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost_IPv4">localHost_IPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost_IPv6">localHost_IPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort">localPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort_IPv4">localPort_IPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort_IPv6">localPort_IPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/maxReceiveIPv4BufferSize">maxReceiveIPv4BufferSize</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/maxReceiveIPv6BufferSize">maxReceiveIPv6BufferSize</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/pauseReceiving">pauseReceiving</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/performBlock:">performBlock:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readStream">readStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/receiveOnce:">receiveOnce:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sendData:toAddress:withTimeout:tag:">sendData:toAddress:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">sendData:toHost:port:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sendData:withTimeout:tag:">sendData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:">setDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:delegateQueue:">setDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegateQueue:">setDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPVersionNeutral">setIPVersionNeutral</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv4Enabled:">setIPv4Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv6Enabled:">setIPv6Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setMaxReceiveIPv4BufferSize:">setMaxReceiveIPv4BufferSize:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setMaxReceiveIPv6BufferSize:">setMaxReceiveIPv6BufferSize:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setPreferIPv4">setPreferIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setPreferIPv6">setPreferIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setReceiveFilter:withQueue:">setReceiveFilter:withQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">setReceiveFilter:withQueue:isAsynchronous:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setSendFilter:withQueue:">setSendFilter:withQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">setSendFilter:withQueue:isAsynchronous:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setUserData:">setUserData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket4FD">socket4FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket6FD">socket6FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socketFD">socketFD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:">synchronouslySetDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">synchronouslySetDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegateQueue:">synchronouslySetDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/userData">userData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeStream">writeStream</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="GCDAsyncUdpSocket Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">GCDAsyncUdpSocket Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">GCDAsyncUdpSocket.h</td>
</tr>
						</tbody></table></div>
					
					
					
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p>

<ol>
<li><p>Optional caching of resolved addresses for domain names.
The cache could later be consulted, resulting in fewer system calls to getaddrinfo.</p></li>
<li><p>Reusable modules of code for bandwidth monitoring.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.
A filter allows you to write custom code to simulate such environments.
The ability to code this yourself is especially helpful when your simulated environment
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>

					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
		<span class="tooltip"><p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithSocketQueue:">&ndash;&nbsp;initWithSocketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:socketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:">&ndash;&nbsp;setDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:">&ndash;&nbsp;synchronouslySetDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegateQueue">&ndash;&nbsp;delegateQueue</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegateQueue:">&ndash;&nbsp;setDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegateQueue:">&ndash;&nbsp;synchronouslySetDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getDelegate:delegateQueue:">&ndash;&nbsp;getDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:delegateQueue:">&ndash;&nbsp;setDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">&ndash;&nbsp;synchronouslySetDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Enabled">&ndash;&nbsp;isIPv4Enabled</a></code>
		<span class="tooltip"><p>By default, both IPv4 and IPv6 are enabled.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv4Enabled:">&ndash;&nbsp;setIPv4Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Enabled">&ndash;&nbsp;isIPv6Enabled</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv6Enabled:">&ndash;&nbsp;setIPv6Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Preferred">&ndash;&nbsp;isIPv4Preferred</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Preferred">&ndash;&nbsp;isIPv6Preferred</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPVersionNeutral">&ndash;&nbsp;isIPVersionNeutral</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setPreferIPv4">&ndash;&nbsp;setPreferIPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setPreferIPv6">&ndash;&nbsp;setPreferIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPVersionNeutral">&ndash;&nbsp;setIPVersionNeutral</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/maxReceiveIPv4BufferSize">&ndash;&nbsp;maxReceiveIPv4BufferSize</a></code>
		<span class="tooltip"><p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 9216 bytes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setMaxReceiveIPv4BufferSize:">&ndash;&nbsp;setMaxReceiveIPv4BufferSize:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/maxReceiveIPv6BufferSize">&ndash;&nbsp;maxReceiveIPv6BufferSize</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setMaxReceiveIPv6BufferSize:">&ndash;&nbsp;setMaxReceiveIPv6BufferSize:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
		<span class="tooltip"><p>User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setUserData:">&ndash;&nbsp;setUserData:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
		<span class="tooltip"><p>Returns the local address info for the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost">&ndash;&nbsp;localHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort">&ndash;&nbsp;localPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress_IPv4">&ndash;&nbsp;localAddress_IPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost_IPv4">&ndash;&nbsp;localHost_IPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort_IPv4">&ndash;&nbsp;localPort_IPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress_IPv6">&ndash;&nbsp;localAddress_IPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost_IPv6">&ndash;&nbsp;localHost_IPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort_IPv6">&ndash;&nbsp;localPort_IPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
		<span class="tooltip"><p>Returns the remote address info for the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedPort">&ndash;&nbsp;connectedPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
		<span class="tooltip"><p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isClosed">&ndash;&nbsp;isClosed</a></code>
		<span class="tooltip"><p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
		<span class="tooltip"><p>Returns whether or not this socket is IPv4.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
		<span class="tooltip"><p>Returns whether or not this socket is IPv6.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bindToPort:error:">&ndash;&nbsp;bindToPort:error:</a></code>
		<span class="tooltip"><p>Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bindToPort:interface:error:">&ndash;&nbsp;bindToPort:interface:error:</a></code>
		<span class="tooltip"><p>Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bindToAddress:error:">&ndash;&nbsp;bindToAddress:error:</a></code>
		<span class="tooltip"><p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
		<span class="tooltip"><p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
		<span class="tooltip"><p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/joinMulticastGroup:error:">&ndash;&nbsp;joinMulticastGroup:error:</a></code>
		<span class="tooltip"><p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/joinMulticastGroup:onInterface:error:">&ndash;&nbsp;joinMulticastGroup:onInterface:error:</a></code>
		<span class="tooltip"><p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/leaveMulticastGroup:error:">&ndash;&nbsp;leaveMulticastGroup:error:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/leaveMulticastGroup:onInterface:error:">&ndash;&nbsp;leaveMulticastGroup:onInterface:error:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/enableBroadcast:error:">&ndash;&nbsp;enableBroadcast:error:</a></code>
		<span class="tooltip"><p>By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sendData:withTimeout:tag:">&ndash;&nbsp;sendData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Asynchronously sends the given data, with the given timeout and tag.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">&ndash;&nbsp;sendData:toHost:port:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sendData:toAddress:withTimeout:tag:">&ndash;&nbsp;sendData:toAddress:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setSendFilter:withQueue:">&ndash;&nbsp;setSendFilter:withQueue:</a></code>
		<span class="tooltip"><p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setSendFilter:withQueue:isAsynchronous:</a></code>
		<span class="tooltip"><p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/receiveOnce:">&ndash;&nbsp;receiveOnce:</a></code>
		<span class="tooltip"><p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/beginReceiving:">&ndash;&nbsp;beginReceiving:</a></code>
		<span class="tooltip"><p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/pauseReceiving">&ndash;&nbsp;pauseReceiving</a></code>
		<span class="tooltip"><p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setReceiveFilter:withQueue:">&ndash;&nbsp;setReceiveFilter:withQueue:</a></code>
		<span class="tooltip"><p>You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of <a href="#//api/name/delegate">delegate</a> queue).</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setReceiveFilter:withQueue:isAsynchronous:</a></code>
		<span class="tooltip"><p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
		<span class="tooltip"><p>Immediately closes the underlying socket.
Any pending send operations are discarded.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/closeAfterSending">&ndash;&nbsp;closeAfterSending</a></code>
		<span class="tooltip"><p>Closes the underlying socket after all pending send operations have been sent.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/performBlock:">&ndash;&nbsp;performBlock:</a></code>
		<span class="tooltip"><p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socketFD">&ndash;&nbsp;socketFD</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket4FD">&ndash;&nbsp;socket4FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket6FD">&ndash;&nbsp;socket6FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readStream">&ndash;&nbsp;readStream</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeStream">&ndash;&nbsp;writeStream</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/hostFromAddress:">+&nbsp;hostFromAddress:</a></code>
		<span class="tooltip"><p>Extracting host/port/family information from raw address data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/portFromAddress:">+&nbsp;portFromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/familyFromAddress:">+&nbsp;familyFromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Address:">+&nbsp;isIPv4Address:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Address:">+&nbsp;isIPv6Address:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getHost:port:fromAddress:">+&nbsp;getHost:port:fromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getHost:port:family:fromAddress:">+&nbsp;getHost:port:family:fromAddress:</a></code>
		
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/familyFromAddress:" title="familyFromAddress:"></a>
	<h3 class="subsubtitle method-title">familyFromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (int)familyFromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getHost:port:family:fromAddress:" title="getHost:port:family:fromAddress:"></a>
	<h3 class="subsubtitle method-title">getHost:port:family:fromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)getHost:(NSString **)<em>hostPtr</em> port:(uint16_t *)<em>portPtr</em> family:(int *)<em>afPtr</em> fromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getHost:port:fromAddress:" title="getHost:port:fromAddress:"></a>
	<h3 class="subsubtitle method-title">getHost:port:fromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)getHost:(NSString **)<em>hostPtr</em> port:(uint16_t *)<em>portPtr</em> fromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/hostFromAddress:" title="hostFromAddress:"></a>
	<h3 class="subsubtitle method-title">hostFromAddress:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Extracting host/port/family information from raw address data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (NSString *)hostFromAddress:(NSData *)<em>address</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Extracting host/port/family information from raw address data.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Address:" title="isIPv4Address:"></a>
	<h3 class="subsubtitle method-title">isIPv4Address:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)isIPv4Address:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Address:" title="isIPv6Address:"></a>
	<h3 class="subsubtitle method-title">isIPv6Address:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)isIPv6Address:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/portFromAddress:" title="portFromAddress:"></a>
	<h3 class="subsubtitle method-title">portFromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (uint16_t)portFromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
					</div>
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/beginReceiving:" title="beginReceiving:"></a>
	<h3 class="subsubtitle method-title">beginReceiving:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)beginReceiving:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>

<p>In one-at-a-time mode, you call receiveOnce everytime your <a href="#//api/name/delegate">delegate</a> is ready to process an incoming udp packet.
Receiving packets one-at-a-time may be better suited for implementing certain state machine code,
where your state machine may not always be ready to process incoming packets.</p>

<p>In continuous mode, the <a href="#//api/name/delegate">delegate</a> is invoked immediately everytime incoming udp packets are received.
Receiving packets continuously is better suited to real-time streaming applications.</p>

<p>You may switch back and forth between one-at-a-time mode and continuous mode.
If the socket is currently in one-at-a-time mode, calling this method will switch it to continuous mode.</p>

<p>For every received packet (not filtered by the optional receive filter),
the <a href="#//api/name/delegate">delegate</a> method (udpSocket:didReceiveData:fromAddress:withFilterContext:) is invoked.</p>

<p>If the socket is able to begin receiving packets, this method returns YES.
Otherwise it returns NO, and sets the errPtr with appropriate error information.</p>

<p>An example error:
You created a udp socket to act as a server, and immediately called receive.
You forgot to first bind the socket to a port number, and received a error with a message like:
&ldquo;Must bind socket before you can receive data.&rdquo;</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bindToAddress:error:" title="bindToAddress:error:"></a>
	<h3 class="subsubtitle method-title">bindToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)bindToAddress:(NSData *)<em>localAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  &ndash;> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa &ndash;> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bindToPort:error:" title="bindToPort:error:"></a>
	<h3 class="subsubtitle method-title">bindToPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You may optionally pass a port number of zero to immediately bind the socket,
yet still allow the OS to automatically assign an available port.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bindToPort:interface:error:" title="bindToPort:interface:error:"></a>
	<h3 class="subsubtitle method-title">bindToPort:interface:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> interface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You may optionally pass a port number of zero to immediately bind the socket,
yet still allow the OS to automatically assign an available port.</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that
the socket only accept packets from the local machine.</p>

<p>You cannot bind a socket after its been connected.
You can only bind a socket once.
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="subsubtitle method-title">close</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Immediately closes the underlying socket.
Any pending send operations are discarded.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)close</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Immediately closes the underlying socket.
Any pending send operations are discarded.</p>

<p>The GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> instance may optionally be used again.
(it will setup/configure/use another unnderlying BSD socket).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/closeAfterSending" title="closeAfterSending"></a>
	<h3 class="subsubtitle method-title">closeAfterSending</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Closes the underlying socket after all pending send operations have been sent.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)closeAfterSending</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Closes the underlying socket after all pending send operations have been sent.</p>

<p>The GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> instance may optionally be used again.
(it will setup/configure/use another unnderlying BSD socket).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:
struct sockaddr sa  &ndash;> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];
struct sockaddr </em>sa &ndash;> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific address has the following effect:
&ndash; You will only be able to send data to the connected address.
&ndash; You will only be able to receive data from the connected address.
&ndash; You will receive ICMP messages that come from the connected address, such as &ldquo;connection refused&rdquo;.</p>

<p>Connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after its been connected.
You can only connect a socket once.</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>

<p>Note: Unlike the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method, this method does not require a DNS lookup.
Thus when this method returns, the connection has either failed or fully completed.
In other words, this method is synchronous, unlike the asynchronous connectToHost::: method.
However, for compatibility and simplification of <a href="#//api/name/delegate">delegate</a> code, if this method returns YES
then the corresponding <a href="#//api/name/delegate">delegate</a> method (udpSocket:didConnectToHost:port:) is still invoked.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific host/port has the following effect:
&ndash; You will only be able to send data to the connected host/port.
&ndash; You will only be able to receive data from the connected host/port.
&ndash; You will receive ICMP messages that come from the connected host/port, such as &ldquo;connection refused&rdquo;.</p>

<p>The actual process of connecting a UDP socket does not result in any communication on the socket.
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after it has been connected.
You can only connect a socket once.</p>

<p>The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).</p>

<p>This method is asynchronous as it requires a DNS lookup to resolve the given host name.
If an obvious error is detected, this method immediately returns NO and sets errPtr.
If you don&rsquo;t care about the error, you can pass nil for errPtr.
Otherwise, this method returns YES and begins the asynchronous connection process.
The result of the asynchronous connection process will be reported via the <a href="#//api/name/delegate">delegate</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="subsubtitle method-title">connectedAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the remote address info for the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the remote address info for the socket.</p>

<p>The connectedAddress method returns a sockaddr structure wrapped in a NSData object.
The <a href="#//api/name/connectedHost">connectedHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Since UDP is connectionless by design, connected address info
will not be available unless the socket is explicitly connected to a remote host/port.
If the socket is not connected, these methods will return nil / 0.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="subsubtitle method-title">connectedHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedPort" title="connectedPort"></a>
	<h3 class="subsubtitle method-title">connectedPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)connectedPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="subsubtitle method-title">delegate</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegateQueue" title="delegateQueue"></a>
	<h3 class="subsubtitle method-title">delegateQueue</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (dispatch_queue_t)delegateQueue</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/enableBroadcast:error:" title="enableBroadcast:error:"></a>
	<h3 class="subsubtitle method-title">enableBroadcast:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)enableBroadcast:(BOOL)<em>flag</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</p>

<p>A broadcast is a UDP message to addresses like &ldquo;192.168.255.255&rdquo; or &ldquo;255.255.255.255&rdquo; that is
delivered to every host on the network.
The reason this is generally disabled by default (by the OS) is to prevent
accidental broadcast messages from flooding the network.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/getDelegate:delegateQueue:" title="getDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">getDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)getDelegate:(id *)<em>delegatePtr</em> delegateQueue:(dispatch_queue_t *)<em>delegateQueuePtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="subsubtitle method-title">init</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)init</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>

<p>You MUST set a <a href="#//api/name/delegate">delegate</a> AND <a href="#//api/name/delegate">delegate</a> dispatch queue before attempting to
use the socket, or you will get an error.</p>

<p>The socket queue is optional.
If you pass NULL, <a href="../Classes/GCDAsyncSocket.html">GCDAsyncSocket</a> will automatically create its own socket queue.
If you choose to provide a socket queue, the socket queue must not be a concurrent queue.</p>

<p>The <a href="#//api/name/delegate">delegate</a> queue and socket queue can optionally be the same.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:" title="initWithDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:socketQueue:" title="initWithDelegate:delegateQueue:socketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:socketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em> socketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithSocketQueue:" title="initWithSocketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithSocketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithSocketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isClosed" title="isClosed"></a>
	<h3 class="subsubtitle method-title">isClosed</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isClosed</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="subsubtitle method-title">isConnected</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPVersionNeutral" title="isIPVersionNeutral"></a>
	<h3 class="subsubtitle method-title">isIPVersionNeutral</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPVersionNeutral</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="subsubtitle method-title">isIPv4</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket is IPv4.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket is IPv4.</p>

<p>By default this will be true, unless:
&ndash; IPv4 is disabled (via <a href="#//api/name/setIPv4Enabled:">setIPv4Enabled:</a>)
&ndash; The socket is explicitly bound to an IPv6 address
&ndash; The socket is connected to an IPv6 address</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Enabled" title="isIPv4Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv4Enabled</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>By default, both IPv4 and IPv6 are enabled.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Enabled</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>By default, both IPv4 and IPv6 are enabled.</p>

<p>This means GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> automatically supports both protocols,
and can send to IPv4 or IPv6 addresses,
as well as receive over IPv4 and IPv6.</p>

<p>For operations that require DNS resolution, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> supports both IPv4 and IPv6.
If a DNS lookup returns only IPv4 results, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> will automatically use IPv4.
If a DNS lookup returns only IPv6 results, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> will automatically use IPv6.
If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference.
If IPv4 is preferred, then IPv4 is used.
If IPv6 is preferred, then IPv6 is used.
If neutral, then the first IP version in the resolved array will be used.</p>

<p>Starting with Mac OS X 10.7 Lion and iOS 5, the default IP preference is neutral.
On prior systems the default IP preference is IPv4.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Preferred" title="isIPv4Preferred"></a>
	<h3 class="subsubtitle method-title">isIPv4Preferred</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Preferred</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv6</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket is IPv6.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket is IPv6.</p>

<p>By default this will be true, unless:
&ndash; IPv6 is disabled (via <a href="#//api/name/setIPv6Enabled:">setIPv6Enabled:</a>)
&ndash; The socket is explicitly bound to an IPv4 address
_ The socket is connected to an IPv4 address</p>

<p>This method will also return false on platforms that do not support IPv6.
Note: The iPhone does not currently support IPv6.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Enabled" title="isIPv6Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv6Enabled</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6Enabled</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Preferred" title="isIPv6Preferred"></a>
	<h3 class="subsubtitle method-title">isIPv6Preferred</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6Preferred</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/joinMulticastGroup:error:" title="joinMulticastGroup:error:"></a>
	<h3 class="subsubtitle method-title">joinMulticastGroup:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/joinMulticastGroup:onInterface:error:" title="joinMulticastGroup:onInterface:error:"></a>
	<h3 class="subsubtitle method-title">joinMulticastGroup:onInterface:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> onInterface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Join multicast group.
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>

<p>On success, returns YES.
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/leaveMulticastGroup:error:" title="leaveMulticastGroup:error:"></a>
	<h3 class="subsubtitle method-title">leaveMulticastGroup:error:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)leaveMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/leaveMulticastGroup:onInterface:error:" title="leaveMulticastGroup:onInterface:error:"></a>
	<h3 class="subsubtitle method-title">leaveMulticastGroup:onInterface:error:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)leaveMulticastGroup:(NSString *)<em>group</em> onInterface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="subsubtitle method-title">localAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local address info for the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local address info for the socket.</p>

<p>The localAddress method returns a sockaddr structure wrapped in a NSData object.
The <a href="#//api/name/localHost">localHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Address info may not be available until after the socket has been binded, connected
or until after data has been sent.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress_IPv4" title="localAddress_IPv4"></a>
	<h3 class="subsubtitle method-title">localAddress_IPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress_IPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress_IPv6" title="localAddress_IPv6"></a>
	<h3 class="subsubtitle method-title">localAddress_IPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress_IPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost" title="localHost"></a>
	<h3 class="subsubtitle method-title">localHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost_IPv4" title="localHost_IPv4"></a>
	<h3 class="subsubtitle method-title">localHost_IPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost_IPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost_IPv6" title="localHost_IPv6"></a>
	<h3 class="subsubtitle method-title">localHost_IPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost_IPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort" title="localPort"></a>
	<h3 class="subsubtitle method-title">localPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort_IPv4" title="localPort_IPv4"></a>
	<h3 class="subsubtitle method-title">localPort_IPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort_IPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort_IPv6" title="localPort_IPv6"></a>
	<h3 class="subsubtitle method-title">localPort_IPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort_IPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/maxReceiveIPv4BufferSize" title="maxReceiveIPv4BufferSize"></a>
	<h3 class="subsubtitle method-title">maxReceiveIPv4BufferSize</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 9216 bytes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (uint16_t)maxReceiveIPv4BufferSize</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 9216 bytes.</p>

<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>

<p>Since the OS/GCD notifies us of the size of each received UDP packet,
the actual allocated buffer size for each packet is exact.
And in practice the size of UDP packets is generally much smaller than the max.
Indeed most protocols will send and receive packets of only a few bytes,
or will set a limit on the size of packets to prevent fragmentation in the IP layer.</p>

<p>If you set the buffer size too small, the sockets API in the OS will silently discard
any extra data, and you will not be notified of the error.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/maxReceiveIPv6BufferSize" title="maxReceiveIPv6BufferSize"></a>
	<h3 class="subsubtitle method-title">maxReceiveIPv6BufferSize</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint32_t)maxReceiveIPv6BufferSize</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/pauseReceiving" title="pauseReceiving"></a>
	<h3 class="subsubtitle method-title">pauseReceiving</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)pauseReceiving</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p>

<p>Important Note:
GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> may be running in parallel with your code.
That is, your <a href="#//api/name/delegate">delegate</a> is likely running on a separate thread/dispatch_queue.
When you invoke this method, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> may have already dispatched <a href="#//api/name/delegate">delegate</a> methods to be invoked.
Thus, if those <a href="#//api/name/delegate">delegate</a> methods have already been dispatch_async&rsquo;d,
your didReceive <a href="#//api/name/delegate">delegate</a> method may still be invoked after this method has been called.
You should be aware of this, and program defensively.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/performBlock:" title="performBlock:"></a>
	<h3 class="subsubtitle method-title">performBlock:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)performBlock:(dispatch_block_t)<em>block</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>

<p>For example, the socket file descriptor.
File descriptors are simply integers which reference an index in the per-process file table.
However, when one requests a new file descriptor (by opening a file or socket),
the file descriptor returned is guaranteed to be the lowest numbered unused descriptor.
So if we&rsquo;re not careful, the following could be possible:</p>

<ul>
<li>Thread A invokes a method which returns the socket&rsquo;s file descriptor.</li>
<li>The socket is closed via the socket&rsquo;s internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket&rsquo;s FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>


<p>In addition to this, other variables are not actually objects,
and thus cannot be retained/released or even autoreleased.
An example is the sslContext, of type SSLContextRef, which is actually a malloc&rsquo;d struct.</p>

<p>Although there are internal variables that make it difficult to maintain thread-safety,
it is important to provide access to these variables
to ensure this class can be used in a wide array of environments.
This method helps to accomplish this by invoking the current block on the socket&rsquo;s internal queue.
The methods below can be invoked from within the block to access
those generally thread-unsafe internal variables in a thread-safe manner.
The given block will be invoked synchronously on the socket&rsquo;s internal queue.</p>

<p>If you save references to any protected variables and use them outside the block, you do so at your own peril.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readStream" title="readStream"></a>
	<h3 class="subsubtitle method-title">readStream</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (CFReadStreamRef)readStream</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Returns (creating if necessary) a CFReadStream/CFWriteStream for the internal socket.</p>

<p>Generally GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> doesn&rsquo;t use CFStream. (It uses the faster GCD API&rsquo;s.)
However, if you need one for any reason,
these methods are a convenient way to get access to a safe instance of one.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/receiveOnce:" title="receiveOnce:"></a>
	<h3 class="subsubtitle method-title">receiveOnce:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)receiveOnce:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>

<p>In one-at-a-time mode, you call receiveOnce everytime your <a href="#//api/name/delegate">delegate</a> is ready to process an incoming udp packet.
Receiving packets one-at-a-time may be better suited for implementing certain state machine code,
where your state machine may not always be ready to process incoming packets.</p>

<p>In continuous mode, the <a href="#//api/name/delegate">delegate</a> is invoked immediately everytime incoming udp packets are received.
Receiving packets continuously is better suited to real-time streaming applications.</p>

<p>You may switch back and forth between one-at-a-time mode and continuous mode.
If the socket is currently in continuous mode, calling this method will switch it to one-at-a-time mode.</p>

<p>When a packet is received (and not filtered by the optional receive filter),
the <a href="#//api/name/delegate">delegate</a> method (udpSocket:didReceiveData:fromAddress:withFilterContext:) is invoked.</p>

<p>If the socket is able to begin receiving packets, this method returns YES.
Otherwise it returns NO, and sets the errPtr with appropriate error information.</p>

<p>An example error:
You created a udp socket to act as a server, and immediately called receive.
You forgot to first bind the socket to a port number, and received a error with a message like:
&ldquo;Must bind socket before you can receive data.&rdquo;</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sendData:toAddress:withTimeout:tag:" title="sendData:toAddress:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">sendData:toAddress:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>

<p>This method cannot be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param address
The address to send the data to (specified as a sockaddr structure wrapped in a NSData object).</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sendData:toHost:port:withTimeout:tag:" title="sendData:toHost:port:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">sendData:toHost:port:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toHost:(NSString *)<em>host</em> port:(uint16_t)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>

<p>This method cannot be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param host
The destination to send the udp packet to.
May be specified as a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).
You may also use the convenience strings of &ldquo;loopback&rdquo; or &ldquo;localhost&rdquo;.</p>

<p>@param port
The port of the host to send to.</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sendData:withTimeout:tag:" title="sendData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">sendData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Asynchronously sends the given data, with the given timeout and tag.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Asynchronously sends the given data, with the given timeout and tag.</p>

<p>This method may only be used with a connected socket.
Recall that connecting is optional for a UDP socket.
For connected sockets, data can only be sent to the connected address.
For non-connected sockets, the remote destination is specified for each packet.
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data
The data to send.
If data is nil or zero-length, this method does nothing.
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param timeout
The timeout for the send opeartion.
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag
The tag is for your convenience.
It is not sent or received over the socket in any manner what-so-ever.
It is reported back as a parameter in the udpSocket:didSendDataWithTag:
or udpSocket:didNotSendDataWithTag:dueToError: methods.
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying
that this particular send operation has completed.
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.
It simply retains it for performance reasons.
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.
Copying this data adds an unwanted/unneeded overhead.
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:" title="setDelegate:"></a>
	<h3 class="subsubtitle method-title">setDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:delegateQueue:" title="setDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegateQueue:" title="setDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPVersionNeutral" title="setIPVersionNeutral"></a>
	<h3 class="subsubtitle method-title">setIPVersionNeutral</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPVersionNeutral</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv4Enabled:" title="setIPv4Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv4Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv4Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv6Enabled:" title="setIPv6Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv6Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv6Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setMaxReceiveIPv4BufferSize:" title="setMaxReceiveIPv4BufferSize:"></a>
	<h3 class="subsubtitle method-title">setMaxReceiveIPv4BufferSize:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setMaxReceiveIPv4BufferSize:(uint16_t)<em>max</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setMaxReceiveIPv6BufferSize:" title="setMaxReceiveIPv6BufferSize:"></a>
	<h3 class="subsubtitle method-title">setMaxReceiveIPv6BufferSize:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setMaxReceiveIPv6BufferSize:(uint32_t)<em>max</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setPreferIPv4" title="setPreferIPv4"></a>
	<h3 class="subsubtitle method-title">setPreferIPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setPreferIPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setPreferIPv6" title="setPreferIPv6"></a>
	<h3 class="subsubtitle method-title">setPreferIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setPreferIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setReceiveFilter:withQueue:" title="setReceiveFilter:withQueue:"></a>
	<h3 class="subsubtitle method-title">setReceiveFilter:withQueue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of <a href="#//api/name/delegate">delegate</a> queue).</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of <a href="#//api/name/delegate">delegate</a> queue).</p>

<p>A filter can provide several useful features.</p>

<ol>
<li><p>Many times udp packets need to be parsed.
Since the filter can run in its own independent queue, you can parallelize this parsing quite easily.
The end result is a parallel socket io, datagram parsing, and packet processing.</p></li>
<li><p>Many times udp packets are discarded because they are duplicate/unneeded/unsolicited.
The filter can prevent such packets from arriving at the <a href="#//api/name/delegate">delegate</a>.
And because the filter can run in its own independent queue, this doesn&rsquo;t slow down the <a href="#//api/name/delegate">delegate</a>.</p></li>
<li><p>Since the udp protocol does not guarantee delivery, udp packets may be lost.
Many protocols built atop udp thus provide various resend/re-request algorithms.
This sometimes results in duplicate packets arriving.
A filter may allow you to architect the duplicate detection code to run in parallel to normal processing.</p></li>
<li><p>Since the udp socket may be connectionless, its possible for unsolicited packets to arrive.
Such packets need to be ignored.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.
A filter allows you to write custom code to simulate such environments.
The ability to code this yourself is especially helpful when your simulated environment
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>Example:</p>

<p>GCDAsyncUdpSocketReceiveFilterBlock filter = ^BOOL (NSData <em>data, NSData </em>address, id *context) {</p>

<p>MyProtocolMessage *msg = [MyProtocol parseMessage:data];</p>

<p>*context = response;
return (response != nil);
};
[udpSocket setReceiveFilter:filter withQueue:myParsingQueue];</p>

<p>For more information about GCDAsyncUdpSocketReceiveFilterBlock, see the documentation for its typedef.
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">setReceiveFilter:withQueue:isAsynchronous:</a> (documented below),
passing YES for the isAsynchronous parameter.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setReceiveFilter:withQueue:isAsynchronous:" title="setReceiveFilter:withQueue:isAsynchronous:"></a>
	<h3 class="subsubtitle method-title">setReceiveFilter:withQueue:isAsynchronous:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>

<p>However, there are a few situations in which synchronous operation is preferred.
Such is the case when the filter is extremely minimal and fast.
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.
Since the socket queue is executing your block via dispatch_sync,
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.
For example, you can&rsquo;t query properties on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:" title="setSendFilter:withQueue:"></a>
	<h3 class="subsubtitle method-title">setSendFilter:withQueue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</p>

<ol>
<li><p>Optional caching of resolved addresses for domain names.
The cache could later be consulted, resulting in fewer system calls to getaddrinfo.</p></li>
<li><p>Reusable modules of code for bandwidth monitoring.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.
A filter allows you to write custom code to simulate such environments.
The ability to code this yourself is especially helpful when your simulated environment
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>For more information about GCDAsyncUdpSocketSendFilterBlock, see the documentation for its typedef.
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">setSendFilter:withQueue:isAsynchronous:</a> (documented below),
passing YES for the isAsynchronous parameter.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:isAsynchronous:" title="setSendFilter:withQueue:isAsynchronous:"></a>
	<h3 class="subsubtitle method-title">setSendFilter:withQueue:isAsynchronous:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The receive filter can be run via dispatch_async or dispatch_sync.
Most typical situations call for asynchronous operation.</p>

<p>However, there are a few situations in which synchronous operation is preferred.
Such is the case when the filter is extremely minimal and fast.
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.
Since the socket queue is executing your block via dispatch_sync,
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.
For example, you can&rsquo;t query properties on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setUserData:" title="setUserData:"></a>
	<h3 class="subsubtitle method-title">setUserData:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setUserData:(id)<em>arbitraryUserData</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket4FD" title="socket4FD"></a>
	<h3 class="subsubtitle method-title">socket4FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket4FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket6FD" title="socket6FD"></a>
	<h3 class="subsubtitle method-title">socket6FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket6FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socketFD" title="socketFD"></a>
	<h3 class="subsubtitle method-title">socketFD</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (int)socketFD</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s file descriptor(s).
If the socket isn&rsquo;t connected, or explicity bound to a particular interface,
it might actually have multiple internal socket file descriptors &ndash; one for IPv4 and one for IPv6.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:" title="synchronouslySetDelegate:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:delegateQueue:" title="synchronouslySetDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegateQueue:" title="synchronouslySetDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="subsubtitle method-title">userData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)userData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/writeStream" title="writeStream"></a>
	<h3 class="subsubtitle method-title">writeStream</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFWriteStreamRef)writeStream</code></div>

    
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2012 Dustin Voss and Robbie Hanson. All rights reserved. (Last updated: 2012-11-06)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 840)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>