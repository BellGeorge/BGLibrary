<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/GCDAsyncUdpSocket.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/GCDAsyncUdpSocket</TokenIdentifier>
			<Abstract type="html">You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>
			
			<NodeRef refid="4"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/init</TokenIdentifier>
			<Abstract type="html">GCDAsyncUdpSocket uses the standard delegate paradigm,
but executes all delegate callbacks on a given delegate dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/initWithSocketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithSocketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithSocketQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/initWithDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/initWithDelegate:delegateQueue:socketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:socketQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/delegate</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)delegate</Declaration>
			
			
			<Anchor>//api/name/delegate</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/setDelegate:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/synchronouslySetDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/delegateQueue</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/delegateQueue</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/synchronouslySetDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/getDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)getDelegate:(id *)delegatePtr delegateQueue:(dispatch_queue_t *)delegateQueuePtr</Declaration>
			
			
			<Anchor>//api/name/getDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/synchronouslySetDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv4Enabled</TokenIdentifier>
			<Abstract type="html">By default, both IPv4 and IPv6 are enabled.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv4Enabled</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setIPv4Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv4Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv4Enabled:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv6Enabled</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv6Enabled</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setIPv6Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv6Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv6Enabled:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv4Preferred</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4Preferred</Declaration>
			
			
			<Anchor>//api/name/isIPv4Preferred</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv6Preferred</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6Preferred</Declaration>
			
			
			<Anchor>//api/name/isIPv6Preferred</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPVersionNeutral</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPVersionNeutral</Declaration>
			
			
			<Anchor>//api/name/isIPVersionNeutral</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setPreferIPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setPreferIPv4</Declaration>
			
			
			<Anchor>//api/name/setPreferIPv4</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setPreferIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setPreferIPv6</Declaration>
			
			
			<Anchor>//api/name/setPreferIPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setIPVersionNeutral</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPVersionNeutral</Declaration>
			
			
			<Anchor>//api/name/setIPVersionNeutral</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/maxReceiveIPv4BufferSize</TokenIdentifier>
			<Abstract type="html">Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 9216 bytes.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)maxReceiveIPv4BufferSize</Declaration>
			
			
			<Anchor>//api/name/maxReceiveIPv4BufferSize</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setMaxReceiveIPv4BufferSize:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setMaxReceiveIPv4BufferSize:(uint16_t)max</Declaration>
			
			
			<Anchor>//api/name/setMaxReceiveIPv4BufferSize:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/maxReceiveIPv6BufferSize</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint32_t)maxReceiveIPv6BufferSize</Declaration>
			
			
			<Anchor>//api/name/maxReceiveIPv6BufferSize</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setMaxReceiveIPv6BufferSize:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setMaxReceiveIPv6BufferSize:(uint32_t)max</Declaration>
			
			
			<Anchor>//api/name/setMaxReceiveIPv6BufferSize:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/userData</TokenIdentifier>
			<Abstract type="html">User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)userData</Declaration>
			
			
			<Anchor>//api/name/userData</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setUserData:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setUserData:(id)arbitraryUserData</Declaration>
			
			
			<Anchor>//api/name/setUserData:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localAddress</TokenIdentifier>
			<Abstract type="html">Returns the local address info for the socket.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress</Declaration>
			
			
			<Anchor>//api/name/localAddress</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost</Declaration>
			
			
			<Anchor>//api/name/localHost</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort</Declaration>
			
			
			<Anchor>//api/name/localPort</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localAddress_IPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress_IPv4</Declaration>
			
			
			<Anchor>//api/name/localAddress_IPv4</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localHost_IPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost_IPv4</Declaration>
			
			
			<Anchor>//api/name/localHost_IPv4</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localPort_IPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort_IPv4</Declaration>
			
			
			<Anchor>//api/name/localPort_IPv4</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localAddress_IPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress_IPv6</Declaration>
			
			
			<Anchor>//api/name/localAddress_IPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localHost_IPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost_IPv6</Declaration>
			
			
			<Anchor>//api/name/localHost_IPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localPort_IPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort_IPv6</Declaration>
			
			
			<Anchor>//api/name/localPort_IPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectedAddress</TokenIdentifier>
			<Abstract type="html">Returns the remote address info for the socket.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)connectedAddress</Declaration>
			
			
			<Anchor>//api/name/connectedAddress</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectedHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)connectedHost</Declaration>
			
			
			<Anchor>//api/name/connectedHost</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectedPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)connectedPort</Declaration>
			
			
			<Anchor>//api/name/connectedPort</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isConnected</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isConnected</Declaration>
			
			
			<Anchor>//api/name/isConnected</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isClosed</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the close methods.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isClosed</Declaration>
			
			
			<Anchor>//api/name/isClosed</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv4</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket is IPv4.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4</Declaration>
			
			
			<Anchor>//api/name/isIPv4</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv6</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket is IPv6.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/bindToPort:error:</TokenIdentifier>
			<Abstract type="html">Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)bindToPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/bindToPort:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/bindToPort:interface:error:</TokenIdentifier>
			<Abstract type="html">Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)bindToPort:(uint16_t)port interface:(NSString *)interface error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/bindToPort:interface:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/bindToAddress:error:</TokenIdentifier>
			<Abstract type="html">Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)bindToAddress:(NSData *)localAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/bindToAddress:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectToHost:onPort:error:</TokenIdentifier>
			<Abstract type="html">Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectToAddress:error:</TokenIdentifier>
			<Abstract type="html">Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/joinMulticastGroup:error:</TokenIdentifier>
			<Abstract type="html">Join multicast group.
Group should be an IP address (eg @&quot;225.228.0.1&quot;).</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)joinMulticastGroup:(NSString *)group error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/joinMulticastGroup:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/joinMulticastGroup:onInterface:error:</TokenIdentifier>
			<Abstract type="html">Join multicast group.
Group should be an IP address (eg @&quot;225.228.0.1&quot;).
The interface may be a name (e.g. &quot;en1&quot; or &quot;lo0&quot;) or the corresponding IP address (e.g. &quot;192.168.4.35&quot;).</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)joinMulticastGroup:(NSString *)group onInterface:(NSString *)interface error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/joinMulticastGroup:onInterface:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/leaveMulticastGroup:error:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)leaveMulticastGroup:(NSString *)group error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/leaveMulticastGroup:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/leaveMulticastGroup:onInterface:error:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)leaveMulticastGroup:(NSString *)group onInterface:(NSString *)interface error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/leaveMulticastGroup:onInterface:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/enableBroadcast:error:</TokenIdentifier>
			<Abstract type="html">By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)enableBroadcast:(BOOL)flag error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/enableBroadcast:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/sendData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Asynchronously sends the given data, with the given timeout and tag.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)sendData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/sendData:withTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/sendData:toHost:port:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)sendData:(NSData *)data toHost:(NSString *)host port:(uint16_t)port withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/sendData:toHost:port:withTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/sendData:toAddress:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Asynchronously sends the given data, with the given timeout and tag, to the given address.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)sendData:(NSData *)data toAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/sendData:toAddress:withTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setSendFilter:withQueue:</TokenIdentifier>
			<Abstract type="html">You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue</Declaration>
			
			
			<Anchor>//api/name/setSendFilter:withQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setSendFilter:withQueue:isAsynchronous:</TokenIdentifier>
			<Abstract type="html">The receive filter can be run via dispatchasync or dispatchsync.
Most typical situations call for asynchronous operation.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue isAsynchronous:(BOOL)isAsynchronous</Declaration>
			
			
			<Anchor>//api/name/setSendFilter:withQueue:isAsynchronous:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/receiveOnce:</TokenIdentifier>
			<Abstract type="html">There are two modes of operation for receiving packets: one-at-a-time &amp;amp; continuous.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)receiveOnce:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/receiveOnce:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/beginReceiving:</TokenIdentifier>
			<Abstract type="html">There are two modes of operation for receiving packets: one-at-a-time &amp;amp; continuous.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)beginReceiving:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/beginReceiving:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/pauseReceiving</TokenIdentifier>
			<Abstract type="html">If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&apos;t read any more packets from the underlying OS socket until beginReceiving is called again.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)pauseReceiving</Declaration>
			
			
			<Anchor>//api/name/pauseReceiving</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setReceiveFilter:withQueue:</TokenIdentifier>
			<Abstract type="html">You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of delegate queue).</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue</Declaration>
			
			
			<Anchor>//api/name/setReceiveFilter:withQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setReceiveFilter:withQueue:isAsynchronous:</TokenIdentifier>
			<Abstract type="html">The receive filter can be run via dispatchasync or dispatchsync.
Most typical situations call for asynchronous operation.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue isAsynchronous:(BOOL)isAsynchronous</Declaration>
			
			
			<Anchor>//api/name/setReceiveFilter:withQueue:isAsynchronous:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/close</TokenIdentifier>
			<Abstract type="html">Immediately closes the underlying socket.
Any pending send operations are discarded.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)close</Declaration>
			
			
			<Anchor>//api/name/close</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/closeAfterSending</TokenIdentifier>
			<Abstract type="html">Closes the underlying socket after all pending send operations have been sent.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)closeAfterSending</Declaration>
			
			
			<Anchor>//api/name/closeAfterSending</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/performBlock:</TokenIdentifier>
			<Abstract type="html">It&apos;s not thread-safe to access certain variables from outside the socket&apos;s internal queue.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)performBlock:(dispatch_block_t)block</Declaration>
			
			
			<Anchor>//api/name/performBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/socketFD</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socketFD</Declaration>
			
			
			<Anchor>//api/name/socketFD</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/socket4FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket4FD</Declaration>
			
			
			<Anchor>//api/name/socket4FD</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/socket6FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket6FD</Declaration>
			
			
			<Anchor>//api/name/socket6FD</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/readStream</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (CFReadStreamRef)readStream</Declaration>
			
			
			<Anchor>//api/name/readStream</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/writeStream</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (CFWriteStreamRef)writeStream</Declaration>
			
			
			<Anchor>//api/name/writeStream</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/hostFromAddress:</TokenIdentifier>
			<Abstract type="html">Extracting host/port/family information from raw address data.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSString *)hostFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/hostFromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/portFromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (uint16_t)portFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/portFromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/familyFromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (int)familyFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/familyFromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/isIPv4Address:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)isIPv4Address:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/isIPv4Address:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/isIPv6Address:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)isIPv6Address:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/isIPv6Address:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/getHost:port:fromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr fromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/getHost:port:fromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/getHost:port:family:fromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr family:(int *)afPtr fromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/getHost:port:family:fromAddress:</Anchor>
		</Token>
		
	</File>
</Tokens>