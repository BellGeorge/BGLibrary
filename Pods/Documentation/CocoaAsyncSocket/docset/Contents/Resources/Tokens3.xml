<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/GCDAsyncSocket.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/GCDAsyncSocket</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>
			
			<NodeRef refid="3"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/init</TokenIdentifier>
			<Abstract type="html">GCDAsyncSocket uses the standard delegate paradigm,
but executes all delegate callbacks on a given delegate dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/initWithSocketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithSocketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithSocketQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/initWithDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/initWithDelegate:delegateQueue:socketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:socketQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/delegate</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)delegate</Declaration>
			
			
			<Anchor>//api/name/delegate</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/setDelegate:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/synchronouslySetDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/delegateQueue</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/delegateQueue</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/synchronouslySetDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/getDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)getDelegate:(id *)delegatePtr delegateQueue:(dispatch_queue_t *)delegateQueuePtr</Declaration>
			
			
			<Anchor>//api/name/getDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/synchronouslySetDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:delegateQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv4Enabled</TokenIdentifier>
			<Abstract type="html">By default, both IPv4 and IPv6 are enabled.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv4Enabled</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setIPv4Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv4Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv4Enabled:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv6Enabled</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv6Enabled</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setIPv6Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv6Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv6Enabled:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv4PreferredOverIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4PreferredOverIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv4PreferredOverIPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setPreferIPv4OverIPv6:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setPreferIPv4OverIPv6:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setPreferIPv4OverIPv6:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/userData</TokenIdentifier>
			<Abstract type="html">User data allows you to associate arbitrary information with the socket.
This data is not used internally by socket in any way.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)userData</Declaration>
			
			
			<Anchor>//api/name/userData</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setUserData:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setUserData:(id)arbitraryUserData</Declaration>
			
			
			<Anchor>//api/name/setUserData:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/acceptOnPort:error:</TokenIdentifier>
			<Abstract type="html">Tells the socket to begin listening and accepting connections on the given port.
When a connection is accepted, a new instance of GCDAsyncSocket will be spawned to handle it,
and the socket:didAcceptNewSocket: delegate method will be invoked.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)acceptOnPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/acceptOnPort:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/acceptOnInterface:port:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as acceptOnPort:error: with the
additional option of specifying which interface to listen on.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)acceptOnInterface:(NSString *)interface port:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/acceptOnInterface:port:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToHost:onPort:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host and port.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToHost:onPort:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host and port with an optional timeout.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:withTimeout:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToHost:onPort:viaInterface:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host &amp;amp; port, via the optional interface, with an optional timeout.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port viaInterface:(NSString *)interface withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:viaInterface:withTimeout:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToAddress:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&apos;s addresses method.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToAddress:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as connectToAddress:error: with an additional timeout option.
To not time out use a negative time interval, or simply use the connectToAddress:error: method.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:withTimeout:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToAddress:viaInterface:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given address, using the specified interface and timeout.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr viaInterface:(NSString *)interface withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:viaInterface:withTimeout:error:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnect</TokenIdentifier>
			<Abstract type="html">Disconnects immediately (synchronously). Any pending reads or writes are dropped.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnect</Declaration>
			
			
			<Anchor>//api/name/disconnect</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnectAfterReading</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will disconnect even if there are still pending writes.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterReading</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterReading</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnectAfterWriting</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will disconnect even if there are still pending reads.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterWriting</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterWriting</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnectAfterReadingAndWriting</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterReadingAndWriting</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterReadingAndWriting</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isDisconnected</TokenIdentifier>
			<Abstract type="html">Returns whether the socket is disconnected or connected.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isDisconnected</Declaration>
			
			
			<Anchor>//api/name/isDisconnected</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isConnected</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isConnected</Declaration>
			
			
			<Anchor>//api/name/isConnected</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectedHost</TokenIdentifier>
			<Abstract type="html">Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)connectedHost</Declaration>
			
			
			<Anchor>//api/name/connectedHost</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectedPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)connectedPort</Declaration>
			
			
			<Anchor>//api/name/connectedPort</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/localHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost</Declaration>
			
			
			<Anchor>//api/name/localHost</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/localPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort</Declaration>
			
			
			<Anchor>//api/name/localPort</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectedAddress</TokenIdentifier>
			<Abstract type="html">Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)connectedAddress</Declaration>
			
			
			<Anchor>//api/name/connectedAddress</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/localAddress</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress</Declaration>
			
			
			<Anchor>//api/name/localAddress</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv4</TokenIdentifier>
			<Abstract type="html">Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4</Declaration>
			
			
			<Anchor>//api/name/isIPv4</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv6</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isSecure</TokenIdentifier>
			<Abstract type="html">Returns whether or not the socket has been secured via SSL/TLS.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isSecure</Declaration>
			
			
			<Anchor>//api/name/isSecure</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataWithTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataWithTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:buffer:bufferOffset:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToLength:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads the given number of bytes.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToLength:withTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToLength:withTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:maxLength:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/progressOfReadReturningTag:bytesDone:total:</TokenIdentifier>
			<Abstract type="html">Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).
The parameters &quot;tag&quot;, &quot;done&quot; and &quot;total&quot; will be filled in if they aren&apos;t NULL.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (float)progressOfReadReturningTag:(long *)tagPtr bytesDone:(NSUInteger *)donePtr total:(NSUInteger *)totalPtr</Declaration>
			
			
			<Anchor>//api/name/progressOfReadReturningTag:bytesDone:total:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/writeData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Writes data to the socket, and calls the delegate when finished.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/writeData:withTimeout:tag:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/progressOfWriteReturningTag:bytesDone:total:</TokenIdentifier>
			<Abstract type="html">Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).
The parameters &quot;tag&quot;, &quot;done&quot; and &quot;total&quot; will be filled in if they aren&apos;t NULL.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (float)progressOfWriteReturningTag:(long *)tagPtr bytesDone:(NSUInteger *)donePtr total:(NSUInteger *)totalPtr</Declaration>
			
			
			<Anchor>//api/name/progressOfWriteReturningTag:bytesDone:total:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/startTLS:</TokenIdentifier>
			<Abstract type="html">Secures the connection using SSL/TLS.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)startTLS:(NSDictionary *)tlsSettings</Declaration>
			
			
			<Anchor>//api/name/startTLS:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/autoDisconnectOnClosedReadStream</TokenIdentifier>
			<Abstract type="html">Traditionally sockets are not closed until the conversation is over.
However, it is technically possible for the remote enpoint to close its write stream.
Our socket would then be notified that there is no more data to be read,
but our socket would still be writeable and the remote endpoint could continue to receive our data.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)autoDisconnectOnClosedReadStream</Declaration>
			
			
			<Anchor>//api/name/autoDisconnectOnClosedReadStream</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setAutoDisconnectOnClosedReadStream:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setAutoDisconnectOnClosedReadStream:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setAutoDisconnectOnClosedReadStream:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/markSocketQueueTargetQueue:</TokenIdentifier>
			<Abstract type="html">GCDAsyncSocket maintains thread safety by using an internal serial dispatch_queue.
In most cases, the instance creates this queue itself.
However, to allow for maximum flexibility, the internal queue may be passed in the init method.
This allows for some advanced options such as controlling socket priority via target queues.
However, when one begins to use target queues like this, they open the door to some specific deadlock issues.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)markSocketQueueTargetQueue:(dispatch_queue_t)socketQueuesPreConfiguredTargetQueue</Declaration>
			
			
			<Anchor>//api/name/markSocketQueueTargetQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/unmarkSocketQueueTargetQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)unmarkSocketQueueTargetQueue:(dispatch_queue_t)socketQueuesPreviouslyConfiguredTargetQueue</Declaration>
			
			
			<Anchor>//api/name/unmarkSocketQueueTargetQueue:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/performBlock:</TokenIdentifier>
			<Abstract type="html">It&apos;s not thread-safe to access certain variables from outside the socket&apos;s internal queue.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)performBlock:(dispatch_block_t)block</Declaration>
			
			
			<Anchor>//api/name/performBlock:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/socketFD</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socketFD</Declaration>
			
			
			<Anchor>//api/name/socketFD</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/socket4FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket4FD</Declaration>
			
			
			<Anchor>//api/name/socket4FD</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/socket6FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket6FD</Declaration>
			
			
			<Anchor>//api/name/socket6FD</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readStream</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFReadStreamRef)readStream</Declaration>
			
			
			<Anchor>//api/name/readStream</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/writeStream</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFWriteStreamRef)writeStream</Declaration>
			
			
			<Anchor>//api/name/writeStream</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/enableBackgroundingOnSocket</TokenIdentifier>
			<Abstract type="html">This method is only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)enableBackgroundingOnSocket</Declaration>
			
			
			<Anchor>//api/name/enableBackgroundingOnSocket</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/sslContext</TokenIdentifier>
			<Abstract type="html">This method is only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (SSLContextRef)sslContext</Declaration>
			
			
			<Anchor>//api/name/sslContext</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/hostFromAddress:</TokenIdentifier>
			<Abstract type="html">Extracting host and port information from raw address data.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSString *)hostFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/hostFromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/portFromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (uint16_t)portFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/portFromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/getHost:port:fromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr fromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/getHost:port:fromAddress:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/CRLFData</TokenIdentifier>
			<Abstract type="html">A few common line separators, for use with the readDataToData:... methods.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)CRLFData</Declaration>
			
			
			<Anchor>//api/name/CRLFData</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/CRData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)CRData</Declaration>
			
			
			<Anchor>//api/name/CRData</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/LFData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)LFData</Declaration>
			
			
			<Anchor>//api/name/LFData</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/ZeroData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)ZeroData</Declaration>
			
			
			<Anchor>//api/name/ZeroData</Anchor>
		</Token>
		
	</File>
</Tokens>